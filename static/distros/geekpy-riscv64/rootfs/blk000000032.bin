he address of the corresponding
   type object.  Reference count and type pointer are filled in; the rest of
   the bytes of the object are *undefined*!  The resulting expression type is
   'type *'.  The size of the object is determined by the tp_basicsize field
   of the type object.

 - PyObject_NewVar(type, typeobj, n) is similar but allocates a variable-size
   object with room for n items.  In addition to the refcount and type pointer
   fields, this also fills in the ob_size field.

 - PyObject_Del(op) releases the memory allocated for an object.  It does not
   run a destructor -- it only frees the memory.  PyObject_Free is identical.

 - PyObject_Init(op, typeobj) and PyObject_InitVar(op, typeobj, n) don't
   allocate memory.  Instead of a 'type' parameter, they take a pointer to a
   new object (allocated by an arbitrary allocator), and initialize its object
   header fields.

Note that objects created with PyObject_{New, NewVar} are allocated using the
specialized Python allocator (implemented in obmalloc.c), if WITH_PYMALLOC is
enabled.  In addition, a special debugging allocator is used if PYMALLOC_DEBUG
is also #defined.

In case a specific form of memory management is needed (for example, if you
must use the platform malloc heap(s), or shared memory, or C++ local storage or
operator new), you must first allocate the object with your custom allocator,
then pass its pointer to PyObject_{Init, InitVar} for filling in its Python-
specific fields:  reference count, type pointer, possibly others.  You should
be aware that Python no control over these objects because they don't
cooperate with the Python memory manager.  Such objects may not be eligible
for automatic garbage collection and you have to make sure that they are
released accordingly whenever their destructor gets called (cf. the specific
form of memory management you're using).

Unless you have specific memory management requirements, use
PyObject_{New, NewVar, Del}.
*/

/*
 * Raw object memory interface
 * ===========================
 */

/* Functions to call the same malloc/realloc/free as used by Python's
   object allocator.  If WITH_PYMALLOC is enabled, these may differ from
   the platform malloc/realloc/free.  The Python object allocator is
   designed for fast, cache-conscious allocation of many "small" objects,
   and with low hidden memory overhead.

   PyObject_Malloc(0) returns a unique non-NULL pointer if possible.

   PyObject_Realloc(NULL, n) acts like PyObject_Malloc(n).
   PyObject_Realloc(p != NULL, 0) does not return  NULL, or free the memory
   at p.

   Returned pointers must be checked for NULL explicitly; no action is
   performed on failure other than to return NULL (no warning it printed, no
   exception is set, etc).

   For allocating objects, use PyObject_{New, NewVar} instead whenever
   possible.  The PyObject_{Malloc, Realloc, Free} family is exposed
   so that you can exploit Python's small-block allocator for non-object
   uses.  If you must use these routines to allocate object memory, make sure
   the object gets initialized via PyObject_{Init, InitVar} after obtaining
   the raw memory.
*/
PyAPI_FUNC(void *) PyObject_Malloc(size_t size);
PyAPI_FUNC(void *) PyObject_Calloc(size_t nelem, size_t elsize);
PyAPI_FUNC(void *) PyObject_Realloc(void *ptr, size_t new_size);
PyAPI_FUNC(void) PyObject_Free(void *ptr);

/* This function returns the number of allocated memory blocks, regardless of size */
PyAPI_FUNC(Py_ssize_t) _Py_GetAllocatedBlocks(void);

/* Macros */
#ifdef WITH_PYMALLOC
#ifndef Py_LIMITED_API
PyAPI_FUNC(void) _PyObject_DebugMallocStats(FILE *out);
#endif /* #ifndef Py_LIMITED_API */
#endif

/* Macros */
#define PyObject_MALLOC         PyObject_Malloc
#define PyObject_REALLOC        PyObject_Realloc
#define PyObject_FREE           PyObject_Free
#define PyObject_Del            PyObject_Free
#define PyObject_DEL            PyObject_Free


/*
 * Generic object allocator interface
 * ==================================
 */

/* Functions */
PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
                                                 PyTypeObject *, Py_ssize_t);
PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);

#define PyObject_New(type, typeobj) \
                ( (type *) _PyObject_New(typeobj) )
#define PyObject_NewVar(type, typeobj, n) \
                ( (type *) _PyObject_NewVar((typeobj), (n)) )

/* Macros trading binary compatibility for speed. See also pymem.h.
   Note that these macros expect non-NULL object pointers.*/
#define PyObject_INIT(op, typeobj) \
    ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
#define PyObject_INIT_VAR(op, typeobj, size) \
    ( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) )

#define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )

/* _PyObject_VAR_SIZE returns the number of bytes (as size_t) allocated for a
   vrbl-size object with nitems items, exclusive of gc overhead (if any).  The
   value is rounded up to the closest multiple of sizeof(void *), in order to
   ensure that pointer fields at the end of the object are correctly aligned
   for the platform (this is of special importance for subclasses of, e.g.,
   str or int, so that pointers can be stored after the embedded data).

   Note that there's no memory wastage in doing this, as malloc has to
   return (at worst) pointer-aligned memory anyway.
*/
#if ((SIZEOF_VOID_P - 1) & SIZEOF_VOID_P) != 0
#   error "_PyObject_VAR_SIZE requires SIZEOF_VOID_P be a power of 2"
#endif

#define _PyObject_VAR_SIZE(typeobj, nitems)     \
    _Py_SIZE_ROUND_UP((typeobj)->tp_basicsize + \
        (nitems)*(typeobj)->tp_itemsize,        \
        SIZEOF_VOID_P)

#define PyObject_NEW(type, typeobj) \
( (type *) PyObject_Init( \
    (PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )

#define PyObject_NEW_VAR(type, typeobj, n) \
( (type *) PyObject_InitVar( \
      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
      (typeobj), (n)) )

/* This example code implements an object constructor with a custom
   allocator, where PyObject_New is inlined, and shows the important
   distinction between two steps (at least):
       1) the actual allocation of the object storage;
       2) the initialization of the Python specific fields
      in this storage with PyObject_{Init, InitVar}.

   PyObject *
   YourObject_New(...)
   {
       PyObject *op;

       op = (PyObject *) Your_Allocator(_PyObject_SIZE(YourTypeStruct));
       if (op == NULL)
       return PyErr_NoMemory();

       PyObject_Init(op, &YourTypeStruct);

       op->ob_field = value;
       ...
       return op;
   }

   Note that in C++, the use of the new operator usually implies that
   the 1st step is performed automatically for you, so in a C++ class
   constructor you would start directly with PyObject_Init/InitVar
*/

#ifndef Py_LIMITED_API
typedef struct {
    /* user context passed as the first argument to the 2 functions */
    void *ctx;

    /* allocate an arena of size bytes */
    void* (*alloc) (void *ctx, size_t size);

    /* free an arena */
    void (*free) (void *ctx, void *ptr, size_t size);
} PyObjectArenaAllocator;

/* Get the arena allocator. */
PyAPI_FUNC(void) PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator);

/* Set the arena allocator. */
PyAPI_FUNC(void) PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator);
#endif


/*
 * Garbage Collection Support
 * ==========================
 */

/* C equivalent of gc.collect(). */
PyAPI_FUNC(Py_ssize_t) PyGC_Collect(void);

#ifndef Py_LIMITED_API
PyAPI_FUNC(Py_ssize_t) _PyGC_CollectNoFail(void);
#endif

/* Test if a type has a GC head */
#define PyType_IS_GC(t) PyType_HasFeature((t), Py_TPFLAGS_HAVE_GC)

/* Test if an object has a GC head */
#define PyObject_IS_GC(o) (PyType_IS_GC(Py_TYPE(o)) && \
    (Py_TYPE(o)->tp_is_gc == NULL || Py_TYPE(o)->tp_is_gc(o)))

PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
#define PyObject_GC_Resize(type, op, n) \
                ( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )

/* GC information is stored BEFORE the object structure. */
#ifndef Py_LIMITED_API
typedef union _gc_head {
    struct {
        union _gc_head *gc_next;
        union _gc_head *gc_prev;
        Py_ssize_t gc_refs;
    } gc;
    double dummy;  /* force worst-case alignment */
} PyGC_Head;

extern PyGC_Head *_PyGC_generation0;

#define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)

/* Bit 0 is set when tp_finalize is called */
#define _PyGC_REFS_MASK_FINALIZED  (1 << 0)
/* The (N-1) most significant bits contain the gc state / refcount */
#define _PyGC_REFS_SHIFT           (1)
#define _PyGC_REFS_MASK            (((size_t) -1) << _PyGC_REFS_SHIFT)

#define _PyGCHead_REFS(g) ((g)->gc.gc_refs >> _PyGC_REFS_SHIFT)
#define _PyGCHead_SET_REFS(g, v) do { \
    (g)->gc.gc_refs = ((g)->gc.gc_refs & ~_PyGC_REFS_MASK) \
        | (((size_t)(v)) << _PyGC_REFS_SHIFT);             \
    } while (0)
#define _PyGCHead_DECREF(g) ((g)->gc.gc_refs -= 1 << _PyGC_REFS_SHIFT)

#define _PyGCHead_FINALIZED(g) (((g)->gc.gc_refs & _PyGC_REFS_MASK_FINALIZED) != 0)
#define _PyGCHead_SET_FINALIZED(g, v) do {  \
    (g)->gc.gc_refs = ((g)->gc.gc_refs & ~_PyGC_REFS_MASK_FINALIZED) \
        | (v != 0); \
    } while (0)

#define _PyGC_FINALIZED(o) _PyGCHead_FINALIZED(_Py_AS_GC(o))
#define _PyGC_SET_FINALIZED(o, v) _PyGCHead_SET_FINALIZED(_Py_AS_GC(o), v)

#define _PyGC_REFS(o) _PyGCHead_REFS(_Py_AS_GC(o))

#define _PyGC_REFS_UNTRACKED                    (-2)
#define _PyGC_REFS_REACHABLE                    (-3)
#define _PyGC_REFS_TENTATIVELY_UNREACHABLE      (-4)

/* Tell the GC to track this object.  NB: While the object is tracked the
 * collector it must be safe to call the ob_traverse method. */
#define _PyObject_GC_TRACK(o) do { \
    PyGC_Head *g = _Py_AS_GC(o); \
    if (_PyGCHead_REFS(g) != _PyGC_REFS_UNTRACKED) \
        Py_FatalError("GC object already tracked"); \
    _PyGCHead_SET_REFS(g, _PyGC_REFS_REACHABLE); \
    g->gc.gc_next = _PyGC_generation0; \
    g->gc.gc_prev = _PyGC_generation0->gc.gc_prev; \
    g->gc.gc_prev->gc.gc_next = g; \
    _PyGC_generation0->gc.gc_prev = g; \
    } while (0);

/* Tell the GC to stop tracking this object.
 * gc_next doesn't need to be set to NULL, but doing so is a good
 * way to provoke memory errors if calling code is confused.
 */
#define _PyObject_GC_UNTRACK(o) do { \
    PyGC_Head *g = _Py_AS_GC(o); \
    assert(_PyGCHead_REFS(g) != _PyGC_REFS_UNTRACKED); \
    _PyGCHead_SET_REFS(g, _PyGC_REFS_UNTRACKED); \
    g->gc.gc_prev->gc.gc_next = g->gc.gc_next; \
    g->gc.gc_next->gc.gc_prev = g->gc.gc_prev; \
    g->gc.gc_next = NULL; \
    } while (0);

/* True if the object is currently tracked by the GC. */
#define _PyObject_GC_IS_TRACKED(o) \
    (_PyGC_REFS(o) != _PyGC_REFS_UNTRACKED)

/* True if the object may be tracked by the GC in the future, or already is.
   This can be useful to implement some optimizations. */
#define _PyObject_GC_MAY_BE_TRACKED(obj) \
    (PyObject_IS_GC(obj) && \
        (!PyTuple_CheckExact(obj) || _PyObject_GC_IS                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              _TRACKED(obj)))
#endif /* Py_LIMITED_API */

PyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t size);
PyAPI_FUNC(PyObject *) _PyObject_GC_Calloc(size_t size);
PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
PyAPI_FUNC(void) PyObject_GC_Track(void *);
PyAPI_FUNC(void) PyObject_GC_UnTrack(void *);
PyAPI_FUNC(void) PyObject_GC_Del(void *);

#define PyObject_GC_New(type, typeobj) \
                ( (type *) _PyObject_GC_New(typeobj) )
#define PyObject_GC_NewVar(type, typeobj, n) \
                ( (type *) _PyObject_GC_NewVar((typeobj), (n)) )


/* Utility macro to help write tp_traverse functions.
 * To use this macro, the tp_traverse function must name its arguments
 * "visit" and "arg".  This is intended to keep tp_traverse functions
 * looking as much alike as possible.
 */
#define Py_VISIT(op)                                                    \
    do {                                                                \
        if (op) {                                                       \
            int vret = visit((PyObject *)(op), arg);                    \
            if (vret)                                                   \
                return vret;                                            \
        }                                                               \
    } while (0)


/* Test if a type supports weak references */
#define PyType_SUPPORTS_WEAKREFS(t) ((t)->tp_weaklistoffset > 0)

#define PyObject_GET_WEAKREFS_LISTPTR(o) \
    ((PyObject **) (((char *) (o)) + Py_TYPE(o)->tp_weaklistoffset))

#ifdef __cplusplus
}
#endif
#endif /* !Py_OBJIMPL_H */
                                                                                                                                                                                                                                                                                                                                                                         L   	objimpl.h   M   setobject.h N   
graminit.h  O   pyfpe.h P   funcobject.hQ   pyhash.hR   
pyerrors.h  S   classobject.h   T   pycapsule.h U   node.h  V   namespaceobject.h   W   floatobject.h   X   genobject.h Y   
abstract.h  Z   
datetime.h  [   py_curses.h \   pythonrun.h E   weakrefobject.h F   Python.hG   
pyconfig.h  H   	pyexpat.h   I   import.hJ   tupleobject.h   K   bitset.hL   	pydebug.h   M   dtoa.h  N   
parsetok.h  O   	grammar.h   P   bytesobject.h   Q   codecs.hR   sysmodule.h S   osdefs.hT   intrcheck.h U   methodobject.h  V   eval.h  W   structmember.h  X   rangeobject.h   Y   moduleobject.h  Z   pymem.h [   token.h \   longintrepr.h   ]   pyport.h^   
pystrhex.h  _   	ucnhash.h   `   fileutils.h a   	pyarena.h   b   enumobject.hc   pytime.hd   	pymacro.h   e  4 	pystate.h                                   /* Set object interface */

#ifndef Py_SETOBJECT_H
#define Py_SETOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

#ifndef Py_LIMITED_API

/* There are three kinds of entries in the table:

1. Unused:  key == NULL
2. Active:  key != NULL and key != dummy
3. Dummy:   key == dummy

The hash field of Unused slots have no meaning.
The hash field of Dummny slots are set to -1
meaning that dummy entries can be detected by
either entry->key==dummy or by entry->hash==-1.
*/

#define PySet_MINSIZE 8

typedef struct {
    PyObject *key;
    Py_hash_t hash;             /* Cached hash code of the key */
} setentry;

/* The SetObject data structure is shared by set and frozenset objects.

Invariant for sets:
 - hash is -1

Invariants for frozensets:
 - data is immutable.
 - hash is the hash of the frozenset or -1 if not computed yet.

*/

typedef struct {
    PyObject_HEAD

    Py_ssize_t fill;            /* Number active and dummy entries*/
    Py_ssize_t used;            /* Number active entries */

    /* The table contains mask + 1 slots, and that's a power of 2.
     * We store the mask instead of the size because the mask is more
     * frequently needed.
     */
    Py_ssize_t mask;

    /* The table points to a fixed-size smalltable for small tables
     * or to additional malloc'ed memory for bigger tables.
     * The table pointer is never NULL which saves us from repeated
     * runtime null-tests.
     */
    setentry *table;
    Py_hash_t hash;             /* Only used by frozenset objects */
    Py_ssize_t finger;          /* Search finger for pop() */

    setentry smalltable[PySet_MINSIZE];
    PyObject *weakreflist;      /* List of weak references */
} PySetObject;

#define PySet_GET_SIZE(so) (((PySetObject *)(so))->used)

PyAPI_DATA(PyObject *) _PySet_Dummy;

PyAPI_FUNC(int) _PySet_NextEntry(PyObject *set, Py_ssize_t *pos, PyObject **key, Py_hash_t *hash);
PyAPI_FUNC(int) _PySet_Update(PyObject *set, PyObject *iterable);
PyAPI_FUNC(int) PySet_ClearFreeList(void);

#endif /* Section excluded by Py_LIMITED_API */

PyAPI_DATA(PyTypeObject) PySet_Type;
PyAPI_DATA(PyTypeObject) PyFrozenSet_Type;
PyAPI_DATA(PyTypeObject) PySetIter_Type;

PyAPI_FUNC(PyObject *) PySet_New(PyObject *);
PyAPI_FUNC(PyObject *) PyFrozenSet_New(PyObject *);

PyAPI_FUNC(int) PySet_Add(PyObject *set, PyObject *key);
PyAPI_FUNC(int) PySet_Clear(PyObject *set);
PyAPI_FUNC(int) PySet_Contains(PyObject *anyset, PyObject *key);
PyAPI_FUNC(int) PySet_Discard(PyObject *set, PyObject *key);
PyAPI_FUNC(PyObject *) PySet_Pop(PyObject *set);
PyAPI_FUNC(Py_ssize_t) PySet_Size(PyObject *anyset);

#define PyFrozenSet_CheckExact(ob) (Py_TYPE(ob) == &PyFrozenSet_Type)
#define PyAnySet_CheckExact(ob) \
    (Py_TYPE(ob) == &PySet_Type || Py_TYPE(ob) == &PyFrozenSet_Type)
#define PyAnySet_Check(ob) \
    (Py_TYPE(ob) == &PySet_Type || Py_TYPE(ob) == &PyFrozenSet_Type || \
      PyType_IsSubtype(Py_TYPE(ob), &PySet_Type) || \
      PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))
#define PySet_Check(ob) \
    (Py_TYPE(ob) == &PySet_Type || \
    PyType_IsSubtype(Py_TYPE(ob), &PySet_Type))
#define   PyFrozenSet_Check(ob) \
    (Py_TYPE(ob) == &PyFrozenSet_Type || \
      PyType_IsSubtype(Py_TYPE(ob), &PyFrozenSet_Type))

#ifdef __cplusplus
}
#endif
#endif /* !Py_SETOBJECT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* Generated by Parser/pgen */

#define single_input 256
#define file_input 257
#define eval_input 258
#define decorator 259
#define decorators 260
#define decorated 261
#define async_funcdef 262
#define funcdef 263
#define parameters 264
#define typedargslist 265
#define tfpdef 266
#define varargslist 267
#define vfpdef 268
#define stmt 269
#define simple_stmt 270
#define small_stmt 271
#define expr_stmt 272
#define testlist_star_expr 273
#define augassign 274
#define del_stmt 275
#define pass_stmt 276
#define flow_stmt 277
#define break_stmt 278
#define continue_stmt 279
#define return_stmt 280
#define yield_stmt 281
#define raise_stmt 282
#define import_stmt 283
#define import_name 284
#define import_from 285
#define import_as_name 286
#define dotted_as_name 287
#define import_as_names 288
#define dotted_as_names 289
#define dotted_name 290
#define global_stmt 291
#define nonlocal_stmt 292
#define assert_stmt 293
#define compound_stmt 294
#define async_stmt 295
#define if_stmt 296
#define while_stmt 297
#define for_stmt 298
#define try_stmt 299
#define with_stmt 300
#define with_item 301
#define except_clause 302
#define suite 303
#define test 304
#define test_nocond 305
#define lambdef 306
#define lambdef_nocond 307
#define or_test 308
#define and_test 309
#define not_test 310
#define comparison 311
#define comp_op 312
#define star_expr 313
#define expr 314
#define xor_expr 315
#define and_expr 316
#define shift_expr 317
#define arith_expr 318
#define term 319
#define factor 320
#define power 321
#define atom_expr 322
#define atom 323
#define testlist_comp 324
#define trailer 325
#define subscriptlist 326
#define subscript 327
#define sliceop 328
#define exprlist 329
#define testlist 330
#define dictorsetmaker 331
#define classdef 332
#define arglist 333
#define argument 334
#define comp_iter 335
#define comp_for 336
#define comp_if 337
#define encoding_decl 338
#define yield_expr 339
#define yield_arg 340
                                                                                                        #ifndef Py_PYFPE_H
#define Py_PYFPE_H
#ifdef __cplusplus
extern "C" {
#endif
/*
     ---------------------------------------------------------------------
    /                       Copyright (c) 1996.                           \
   |          The Regents of the University of California.                 |
   |                        All rights reserved.                           |
   |                                                                       |
   |   Permission to use, copy, modify, and distribute this software for   |
   |   any purpose without fee is hereby granted, provided that this en-   |
   |   tire notice is included in all copies of any software which is or   |
   |   includes  a  copy  or  modification  of  this software and in all   |
   |   copies of the supporting documentation for such software.           |
   |                                                                       |
   |   This  work was produced at the University of California, Lawrence   |
   |   Livermore National Laboratory under  contract  no.  W-7405-ENG-48   |
   |   between  the  U.S.  Department  of  Energy and The Regents of the   |
   |   University of California for the operation of UC LLNL.              |
   |                                                                       |
   |                              DISCLAIMER                               |
   |                                                                       |
   |   This  software was prepared as an account of work sponsored by an   |
   |   agency of the United States Government. Neither the United States   |
   |   Government  nor the University of California nor any of their em-   |
   |   ployees, makes any warranty, express or implied, or  assumes  any   |
   |   liability  or  responsibility  for the accuracy, completeness, or   |
   |   usefulness of any information,  apparatus,  product,  or  process   |
   |   disclosed,   or  represents  that  its  use  would  not  infringe   |
   |   privately-owned rights. Reference herein to any specific  commer-   |
   |   cial  products,  process,  or  service  by trade name, trademark,   |
   |   manufacturer, or otherwise, does not  necessarily  constitute  or   |
   |   imply  its endorsement, recommendation, or favoring by the United   |
   |   States Government or the University of California. The views  and   |
   |   opinions  of authors expressed herein do not necessarily state or   |
   |   reflect those of the United States Government or  the  University   |
   |   of  California,  and shall not be used for advertising or product   |
    \  endorsement purposes.                                              /
     ---------------------------------------------------------------------
*/

/*
 *       Define macros for handling SIGFPE.
 *       Lee Busby, LLNL, November, 1996
 *       busby1@llnl.gov
 * 
 *********************************************
 * Overview of the system for handling SIGFPE:
 * 
 * This file (Include/pyfpe.h) defines a couple of "wrapper" macros for
 * insertion into your Python C code of choice. Their proper use is
 * discussed below. The file Python/pyfpe.c defines a pair of global
 * variables PyFPE_jbuf and PyFPE_counter which are used by the signal
 * handler for SIGFPE to decide if a particular exception was protected
 * by the macros. The signal handler itself, and code for enabling the
 * generation of SIGFPE in the first place, is in a (new) Python module
 * named fpectl. This module is standard in every respect. It can be loaded
 * either statically or dynamically as you choose, and like any other
 * Python module, has no effect until you import it.
 * 
 * In the general case, there are three steps toward handling SIGFPE in any
 * Python code:
 * 
 * 1) Add the *_PROTECT macros to your C code as required to protect
 *    dangerous floating point sections.
 * 
 * 2) Turn on the inclusion of the code by adding the ``--with-fpectl''
 *    flag at the time you run configure.  If the fpectl or other modules
 *    which use the *_PROTECT macros are to be dynamically loaded, be
 *    sure they are compiled with WANT_SIGFPE_HANDLER defined.
 * 
 * 3) When python is built and running, import fpectl, and execute
 *    fpectl.turnon_sigfpe(). This sets up the signal handler and enables
 *    generation of SIGFPE whenever an exception occurs. From this point
 *    on, any properly trapped SIGFPE should result in the Python
 *    FloatingPointError exception.
 * 
 * Step 1 has been done already for the Python kernel code, and should be
 * done soon for the NumPy array package.  Step 2 is usually done once at
 * python install time. Python's behavior with respect to SIGFPE is not
 * changed unless you also do step 3. Thus you can control this new
 * facility at compile time, or run time, or both.
 * 
 ******************************** 
 * Using the macros in your code:
 * 
 * static PyObject *foobar(PyObject *self,PyObject *args)
 * {
 *     ....
 *     PyFPE_START_PROTECT("Error in foobar", return 0)
 *     result = dangerous_op(somearg1, somearg2, ...);
 *     PyFPE_END_PROTECT(result)
 *     ....
 * }
 * 
 * If a floating point error occurs in dangerous_op, foobar returns 0 (NULL),
 * after setting the associated value of the FloatingPointError exception to
 * "Error in foobar". ``Dangerous_op'' can be a single operation, or a block
 * of code, function calls, or any combination, so long as no alternate
 * return is possible before the PyFPE_END_PROTECT macro is reached.
 * 
 * The macros can only be used in a function context where an error return
 * can be recognized as signaling a Python exception. (Generally, most
 * functions that return a PyObject * will qualify.)
 * 
 * Guido's original design suggestion for PyFPE_START_PROTECT and
 * PyFPE_END_PROTECT had them open and close a local block, with a locally
 * defined jmp_buf and jmp_buf pointer. This would allow recursive nesting
 * of the macros. The Ansi C standard makes it clear that such local
 * variables need to be declared with the "volatile" type qualifier to keep
 * setjmp from corrupting their values. Some current implementations seem
 * to be more restrictive. For example, the HPUX man page for setjmp says
 * 
 *   Upon the return from a setjmp() call caused by a longjmp(), the
 *   values of any non-static local variables belonging to the routine
 *   from which setjmp() was called are undefined. Code which depends on
 *   such values is not guaranteed to be portable.
 * 
 * I therefore decided on a more limited form of nesting, using a counter
 * variable (PyFPE_counter) to keep track of any recursion.  If an exception
 * occurs in an ``inner'' pair of macros, the return will apparently
 * come from the outermost level.
 * 
 */

#ifdef WANT_SIGFPE_HANDLER
#include <signal.h>
#include <setjmp.h>
#include <math.h>
extern jmp_buf PyFPE_jbuf;
extern int PyFPE_counter;
extern double PyFPE_dummy(void *);

#define PyFPE_START_PROTECT(err_string, leave_stmt) \
if (!PyFPE_counter++ && setjmp(PyFPE_jbuf)) { \
	PyErr_SetString(PyExc_FloatingPointError, err_string); \
	PyFPE_counter = 0; \
	leave_stmt; \
}

/*
 * This (following) is a heck of a way to decrement a counter. However,
 * unless the macro argument is provided, code optimizers will sometimes move
 * this statement so that it gets executed *before* the unsafe expression
 * which we're trying to protect.  That pretty well messes things up,
 * of course.
 * 
 * If the expression(s) you're trying to protect don't happen to return a
 * value, you will need to manufacture a dummy result just to preserve the
 * correct ordering of statements.  Note that the macro passes the address
 * of its argument (so you need to give it something which is addressable).
 * If your expression returns multiple results, pass the last such result
 * to PyFPE_END_PROTECT.
 * 
 * Note that PyFPE_dummy returns a double, which is cast to int.
 * This seeming insanity is to tickle the Floating Point Unit (FPU).
 * If an exception has occurred in a preceding floating point operation,
 * some architectures (notably Intel 80x86) will not deliver the interrupt
 * until the *next* floating point operation.  This is painful if you've
 * already decremented PyFPE_counter.
 */
#define PyFPE_END_PROTECT(v) PyFPE_counter -= (int)PyFPE_dummy(&(v));

#else

#define PyFPE_START_PROTECT(err_string, leave_stmt)
#define PyFPE_END_PROTECT(v)

#endif

#ifdef __cplusplus
}
#endif
#endif /* !Py_PYFPE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
/* Function object interface */
#ifndef Py_LIMITED_API
#ifndef Py_FUNCOBJECT_H
#define Py_FUNCOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

/* Function objects and code objects should not be confused with each other:
 *
 * Function objects are created by the execution of the 'def' statement.
 * They reference a code object in their __code__ attribute, which is a
 * purely syntactic object, i.e. nothing more than a compiled version of some
 * source code lines.  There is one code object per source code "fragment",
 * but each code object can be referenced by zero or many function objects
 * depending only on how many times the 'def' statement in the source was
 * executed so far.
 */

typedef struct {
    PyObject_HEAD
    PyObject *func_code;	/* A code object, the __code__ attribute */
    PyObject *func_globals;	/* A dictionary (other mappings won't do) */
    PyObject *func_defaults;	/* NULL or a tuple */
    PyObject *func_kwdefaults;	/* NULL or a dict */
    PyObject *func_closure;	/* NULL or a tuple of cell objects */
    PyObject *func_doc;		/* The __doc__ attribute, can be anything */
    PyObject *func_name;	/* The __name__ attribute, a string object */
    PyObject *func_dict;	/* The __dict__ attribute, a dict or NULL */
    PyObject *func_weakreflist;	/* List of weak references */
    PyObject *func_module;	/* The __module__ attribute, can be anything */
    PyObject *func_annotations;	/* Annotations, a dict or NULL */
    PyObject *func_qualname;    /* The qualified name */

    /* Invariant:
     *     func_closure contains the bindings for func_code->co_freevars, so
     *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)
     *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).
     */
} PyFunctionObject;

PyAPI_DATA(PyTypeObject) PyFunction_Type;

#define PyFunction_Check(op) (Py_TYPE(op) == &PyFunction_Type)

PyAPI_FUNC(PyObject *) PyFunction_New(PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_NewWithQualName(PyObject *, PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetCode(PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetGlobals(PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetModule(PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetDefaults(PyObject *);
PyAPI_FUNC(int) PyFunction_SetDefaults(PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetKwDefaults(PyObject *);
PyAPI_FUNC(int) PyFunction_SetKwDefaults(PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetClosure(PyObject *);
PyAPI_FUNC(int) PyFunction_SetClosure(PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyFunction_GetAnnotations(PyObject *);
PyAPI_FUNC(int) PyFunction_SetAnnotations(PyObject *, PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
#define PyFunction_GET_CODE(func) \
        (((PyFunctionObject *)func) -> func_code)
#define PyFunction_GET_GLOBALS(func) \
	(((PyFunctionObject *)func) -> func_globals)
#define PyFunction_GET_MODULE(func) \
	(((PyFunctionObject *)func) -> func_module)
#define PyFunction_GET_DEFAULTS(func) \
	(((PyFunctionObject *)func) -> func_defaults)
#define PyFunction_GET_KW_DEFAULTS(func) \
	(((PyFunctionObject *)func) -> func_kwdefaults)
#define PyFunction_GET_CLOSURE(func) \
	(((PyFunctionObject *)func) -> func_closure)
#define PyFunction_GET_ANNOTATIONS(func) \
	(((PyFunctionObject *)func) -> func_annotations)

/* The classmethod and staticmethod types lives here, too */
PyAPI_DATA(PyTypeObject) PyClassMethod_Type;
PyAPI_DATA(PyTypeObject) PyStaticMethod_Type;

PyAPI_FUNC(PyObject *) PyClassMethod_New(PyObject *);
PyAPI_FUNC(PyObject *) PyStaticMethod_New(PyObject *);

#ifdef __cplusplus
}
#endif
#endif /* !Py_FUNCOBJECT_H */
#endif /* Py_LIMITED_API */
                                                                                                                                                                                                                                                                                                                                     #ifndef Py_HASH_H

#define Py_HASH_H
#ifdef __cplusplus
extern "C" {
#endif

/* Helpers for hash functions */
#ifndef Py_LIMITED_API
PyAPI_FUNC(Py_hash_t) _Py_HashDouble(double);
PyAPI_FUNC(Py_hash_t) _Py_HashPointer(void*);
PyAPI_FUNC(Py_hash_t) _Py_HashBytes(const void*, Py_ssize_t);
#endif

/* Prime multiplier used in string and various other hashes. */
#define _PyHASH_MULTIPLIER 1000003UL  /* 0xf4243 */

/* Parameters used for the numeric hash implementation.  See notes for
   _Py_HashDouble in Objects/object.c.  Numeric hashes are based on
   reduction modulo the prime 2**_PyHASH_BITS - 1. */

#if SIZEOF_VOID_P >= 8
#  define _PyHASH_BITS 61
#else
#  define _PyHASH_BITS 31
#endif

#define _PyHASH_MODULUS (((size_t)1 << _PyHASH_BITS) - 1)
#define _PyHASH_INF 314159
#define _PyHASH_NAN 0
#define _PyHASH_IMAG _PyHASH_MULTIPLIER


/* hash secret
 *
 * memory layout on 64 bit systems
 *   cccccccc cccccccc cccccccc  uc -- unsigned char[24]
 *   pppppppp ssssssss ........  fnv -- two Py_hash_t
 *   k0k0k0k0 k1k1k1k1 ........  siphash -- two PY_UINT64_T
 *   ........ ........ ssssssss  djbx33a -- 16 bytes padding + one Py_hash_t
 *   ........ ........ eeeeeeee  pyexpat XML hash salt
 *
 * memory layout on 32 bit systems
 *   cccccccc cccccccc cccccccc  uc
 *   ppppssss ........ ........  fnv -- two Py_hash_t
 *   k0k0k0k0 k1k1k1k1 ........  siphash -- two PY_UINT64_T (*)
 *   ........ ........ ssss....  djbx33a -- 16 bytes padding + one Py_hash_t
 *   ........ ........ eeee....  pyexpat XML hash salt
 *
 * (*) The siphash member may not be available on 32 bit platforms without
 *     an unsigned int64 data type.
 */
#ifndef Py_LIMITED_API
typedef union {
    /* ensure 24 bytes */
    unsigned char uc[24];
    /* two Py_hash_t for FNV */
    struct {
        Py_hash_t prefix;
        Py_hash_t suffix;
    } fnv;
#ifdef PY_UINT64_T
    /* two uint64 for SipHash24 */
    struct {
        PY_UINT64_T k0;
        PY_UINT64_T k1;
    } siphash;
#endif
    /* a different (!) Py_hash_t for small string optimization */
    struct {
        unsigned char padding[16];
        Py_hash_t suffix;
    } djbx33a;
    struct {
        unsigned char padding[16];
        Py_hash_t hashsalt;
    } expat;
} _Py_HashSecret_t;
PyAPI_DATA(_Py_HashSecret_t) _Py_HashSecret;
#endif

#ifdef Py_DEBUG
PyAPI_DATA(int) _Py_HashSecret_Initialized;
#endif


/* hash function definition */
#ifndef Py_LIMITED_API
typedef struct {
    Py_hash_t (*const hash)(const void *, Py_ssize_t);
    const char *name;
    const int hash_bits;
    const int seed_bits;
} PyHash_FuncDef;

PyAPI_FUNC(PyHash_FuncDef*) PyHash_GetFuncDef(void);
#endif


/* cutoff for small string DJBX33A optimization in range [1, cutoff).
 *
 * About 50% of the strings in a typical Python application are smaller than
 * 6 to 7 chars. However DJBX33A is vulnerable to hash collision attacks.
 * NEVER use DJBX33A for long strings!
 *
 * A Py_HASH_CUTOFF of 0 disables small string optimization. 32 bit platforms
 * should use a smaller cutoff because it is easier to create colliding
 * strings. A cutoff of 7 on 64bit platforms and 5 on 32bit platforms should
 * provide a decent safety margin.
 */
#ifndef Py_HASH_CUTOFF
#  define Py_HASH_CUTOFF 0
#elif (Py_HASH_CUTOFF > 7 || Py_HASH_CUTOFF < 0)
#  error Py_HASH_CUTOFF must in range 0...7.
#endif /* Py_HASH_CUTOFF */


/* hash algorithm selection
 *
 * The values for Py_HASH_SIPHASH24 and Py_HASH_FNV are hard-coded in the
 * configure script.
 *
 * - FNV is available on all platforms and architectures.
 * - SIPHASH24 only works on plaforms that provide PY_UINT64_T and doesn't
 *   require aligned memory for integers.
 * - With EXTERNAL embedders can provide an alternative implementation with::
 *
 *     PyHash_FuncDef PyHash_Func = {...};
 *
 * XXX: Figure out __declspec() for extern PyHash_FuncDef.
 */
#define Py_HASH_EXTERNAL 0
#define Py_HASH_SIPHASH24 1
#define Py_HASH_FNV 2

#ifndef Py_HASH_ALGORITHM
#  if (defined(PY_UINT64_T) && defined(PY_UINT32_T) \
       && !defined(HAVE_ALIGNED_REQUIRED))
#    define Py_HASH_ALGORITHM Py_HASH_SIPHASH24
#  else
#    define Py_HASH_ALGORITHM Py_HASH_FNV
#  endif /* uint64_t && uint32_t && aligned */
#endif /* Py_HASH_ALGORITHM */

#ifdef __cplusplus
}
#endif

#endif /* !Py_HASH_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              #ifndef Py_ERRORS_H
#define Py_ERRORS_H
#ifdef __cplusplus
extern "C" {
#endif

/* Error objects */

#ifndef Py_LIMITED_API
/* PyException_HEAD defines the initial segment of every exception class. */
#define PyException_HEAD PyObject_HEAD PyObject *dict;\
             PyObject *args; PyObject *traceback;\
             PyObject *context; PyObject *cause;\
             char suppress_context;

typedef struct {
    PyException_HEAD
} PyBaseExceptionObject;

typedef struct {
    PyException_HEAD
    PyObject *msg;
    PyObject *filename;
    PyObject *lineno;
    PyObject *offset;
    PyObject *text;
    PyObject *print_file_and_line;
} PySyntaxErrorObject;

typedef struct {
    PyException_HEAD
    PyObject *msg;
    PyObject *name;
    PyObject *path;
} PyImportErrorObject;

typedef struct {
    PyException_HEAD
    PyObject *encoding;
    PyObject *object;
    Py_ssize_t start;
    Py_ssize_t end;
    PyObject *reason;
} PyUnicodeErrorObject;

typedef struct {
    PyException_HEAD
    PyObject *code;
} PySystemExitObject;

typedef struct {
    PyException_HEAD
    PyObject *myerrno;
    PyObject *strerror;
    PyObject *filename;
    PyObject *filename2;
#ifdef MS_WINDOWS
    PyObject *winerror;
#endif
    Py_ssize_t written;   /* only for BlockingIOError, -1 otherwise */
} PyOSErrorObject;

typedef struct {
    PyException_HEAD
    PyObject *value;
} PyStopIterationObject;

/* Compatibility typedefs */
typedef PyOSErrorObject PyEnvironmentErrorObject;
#ifdef MS_WINDOWS
typedef PyOSErrorObject PyWindowsErrorObject;
#endif
#endif /* !Py_LIMITED_API */

/* Error handling definitions */

PyAPI_FUNC(void) PyErr_SetNone(PyObject *);
PyAPI_FUNC(void) PyErr_SetObject(PyObject *, PyObject *);
#ifndef Py_LIMITED_API
PyAPI_FUNC(void) _PyErr_SetKeyError(PyObject *);
#endif
PyAPI_FUNC(void) PyErr_SetString(
    PyObject *exception,
    const char *string   /* decoded from utf-8 */
    );
PyAPI_FUNC(PyObject *) PyErr_Occurred(void);
PyAPI_FUNC(void) PyErr_Clear(void);
PyAPI_FUNC(void) PyErr_Fetch(PyObject **, PyObject **, PyObject **);
PyAPI_FUNC(void) PyErr_Restore(PyObject *, PyObject *, PyObject *);
PyAPI_FUNC(void) PyErr_GetExcInfo(PyObject **, PyObject **, PyObject **);
PyAPI_FUNC(void) PyErr_SetExcInfo(PyObject *, PyObject *, PyObject *);

#if defined(__clang__) || \
    (defined(__GNUC_MAJOR__) && \
     ((__GNUC_MAJOR__ >= 3) || \
      (__GNUC_MAJOR__ == 2) && (__GNUC_MINOR__ >= 5)))
#define _Py_NO_RETURN __attribute__((__noreturn__))
#else
#define _Py_NO_RETURN
#endif

/* Defined in Python/pylifecycle.c */
PyAPI_FUNC(void) Py_FatalError(const char *message) _Py_NO_RETURN;

#if defined(Py_DEBUG) || defined(Py_LIMITED_API)
#define _PyErr_OCCURRED() PyErr_Occurred()
#else
#define _PyErr_OCCURRED() (PyThreadState_GET()->curexc_type)
#endif

/* Error testing and normalization */
PyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);
PyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);
PyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);

/* Traceback manipulation (PEP 3134) */
PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyException_GetTraceback(PyObject *);

/* Cause manipulation (PEP 3134) */
PyAPI_FUNC(PyObject *) PyException_GetCause(PyObject *);
PyAPI_FUNC(void) PyException_SetCause(PyObject *, PyObject *);

/* Context manipulation (PEP 3134) */
PyAPI_FUNC(PyObject *) PyException_GetContext(PyObject *);
PyAPI_FUNC(void) PyException_SetContext(PyObject *, PyObject *);
#ifndef Py_LIMITED_API
PyAPI_FUNC(void) _PyErr_ChainExceptions(PyObject *, PyObject *, PyObject *);
#endif

/* */

#define PyExceptionClass_Check(x)                                       \
    (PyType_Check((x)) &&                                               \
     PyType_FastSubclass((PyTypeObject*)(x), Py_TPFLAGS_BASE_EXC_SUBCLASS))

#define PyExceptionInstance_Check(x)                    \
    PyType_FastSubclass((x)->ob_type, Py_TPFLAGS_BASE_EXC_SUBCLASS)

#define PyExceptionClass_Name(x) \
     ((char *)(((PyTypeObject*)(x))->tp_name))

#define PyExceptionInstance_Class(x) ((PyObject*)((x)->ob_type))


/* Predefined exceptions */

PyAPI_DATA(PyObject *) PyExc_BaseException;
PyAPI_DATA(PyObject *) PyExc_Exception;
PyAPI_DATA(PyObject *) PyExc_StopAsyncIteration;
PyAPI_DATA(PyObject *) PyExc_StopIteration;
PyAPI_DATA(PyObject *) PyExc_GeneratorExit;
PyAPI_DATA(PyObject *) PyExc_ArithmeticError;
PyAPI_DATA(PyObject *) PyExc_LookupError;

PyAPI_DATA(PyObject *) PyExc_AssertionError;
PyAPI_DATA(PyObject *) PyExc_AttributeError;
PyAPI_DATA(PyObject *) PyExc_BufferError;
PyAPI_DATA(PyObject *) PyExc_EOFError;
PyAPI_DATA(PyObject *) PyExc_FloatingPointError;
PyAPI_DATA(PyObject *) PyExc_OSError;
PyAPI_DATA(PyObject *) PyExc_ImportError;
PyAPI_DATA(PyObject *) PyExc_IndexError;
PyAPI_DATA(PyObject *) PyExc_KeyError;
PyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;
PyAPI_DATA(PyObject *) PyExc_MemoryError;
PyAPI_DATA(PyObject *) PyExc_NameError;
PyAPI_DATA(PyObject *) PyExc_OverflowError;
PyAPI_DATA(PyObject *) PyExc_RuntimeError;
PyAPI_DATA(PyObject *) PyExc_RecursionError;
PyAPI_DATA(PyObject *) PyExc_NotImplementedError;
PyAPI_DATA(PyObject *) PyExc_SyntaxError;
PyAPI_DATA(PyObject *) PyExc_IndentationError;
PyAPI_DATA(PyObject *) PyExc_TabError;
PyAPI_DATA(PyObject *) PyExc_ReferenceError;
PyAPI_DATA(PyObject *) PyExc_SystemError;
PyAPI_DATA(PyObject *) PyExc_SystemExit;
PyAPI_DATA(PyObject *) PyExc_TypeError;
PyAPI_DATA(PyObject *) PyExc_UnboundLocalError;
PyAPI_DATA(PyObject *) PyExc_UnicodeError;
PyAPI_DATA(PyObject *) PyExc_UnicodeEncodeError;
PyAPI_DATA(PyObject *) PyExc_UnicodeDecodeError;
PyAPI_DATA(PyObject *) PyExc_UnicodeTranslateError;
PyAPI_DATA(PyObject *) PyExc_ValueError;
PyAPI_DATA(PyObject *) PyExc_ZeroDivisionError;

PyAPI_DATA(PyObject *) PyExc_BlockingIOError;
PyAPI_DATA(PyObject *) PyExc_BrokenPipeError;
PyAPI_DATA(PyObject *) PyExc_ChildProcessError;
PyAPI_DATA(PyObject *) PyExc_ConnectionError;
PyAPI_DATA(PyObject *) PyExc_ConnectionAbortedError;
PyAPI_DATA(PyObject *) PyExc_ConnectionRefusedError;
PyAPI_DATA(PyObject *) PyExc_ConnectionResetError;
PyAPI_DATA(PyObject *) PyExc_FileExistsError;
PyAPI_DATA(PyObject *) PyExc_FileNotFoundError;
PyAPI_DATA(PyObject *) PyExc_InterruptedError;
PyAPI_DATA(PyObject *) PyExc_IsADirectoryError;
PyAPI_DATA(PyObject *) PyExc_NotADirectoryError;
PyAPI_DATA(PyObject *) PyExc_PermissionError;
PyAPI_DATA(PyObject *) PyExc_ProcessLookupError;
PyAPI_DATA(PyObject *) PyExc_TimeoutError;


/* Compatibility aliases */
PyAPI_DATA(PyObject *) PyExc_EnvironmentError;
PyAPI_DATA(PyObject *) PyExc_IOError;
#ifdef MS_WINDOWS
PyAPI_DATA(PyObject *) PyExc_WindowsError;
#endif

PyAPI_DATA(PyObject *) PyExc_RecursionErrorInst;

/* Predefined warning categories */
PyAPI_DATA(PyObject *) PyExc_Warning;
PyAPI_DATA(PyObject *) PyExc_UserWarning;
PyAPI_DATA(PyObject *) PyExc_DeprecationWarning;
PyAPI_DATA(PyObject *) PyExc_PendingDeprecationWarning;
PyAPI_DATA(PyObject *) PyExc_SyntaxWarning;
PyAPI_DATA(PyObject *) PyExc_RuntimeWarning;
PyAPI_DATA(PyObject *) PyExc_FutureWarning;
PyAPI_DATA(PyObject *) PyExc_ImportWarning;
PyAPI_DATA(PyObject *) PyExc_UnicodeWarning;
PyAPI_DATA(PyObject *) PyExc_BytesWarning;
PyAPI_DATA(PyObject *) PyExc_ResourceWarning;


/* Convenience functions */

PyAPI_FUNC(int) PyErr_BadArgument(void);
PyAPI_FUNC(PyObject *) PyErr_NoMemory(void);
PyAPI_FUNC(PyObject *) PyErr_SetFromErrno(PyObject *);
PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObject(
    PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilenameObjects(
    PyObject *, PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithFilename(
    PyObject *exc,
    const char *filename   /* decoded from the filesystem encoding */
    );
#if defined(MS_WINDOWS) && !defined(Py_LIMITED_API)
PyAPI_FUNC(PyObject *) PyErr_SetFromErrnoWithUnicodeFilename(
    PyObject *, const Py_UNICODE *);
#endif /* MS_WINDOWS */

PyAPI_FUNC(PyObject *) PyErr_Format(
    PyObject *exception,
    const char *format,   /* ASCII-encoded string  */
    ...
    );
#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x03050000
PyAPI_FUNC(PyObject *) PyErr_FormatV(
    PyObject *exception,
    const char *format,
    va_list vargs);
#endif

#ifdef MS_WINDOWS
PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithFilename(
    int ierr,
    const char *filename        /* decoded from the filesystem encoding */
    );
#ifndef Py_LIMITED_API
/* XXX redeclare to use WSTRING */
PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErrWithUnicodeFilename(
    int, const Py_UNICODE *);
#endif
PyAPI_FUNC(PyObject *) PyErr_SetFromWindowsErr(int);
PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObject(
    PyObject *,int, PyObject *);
PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilenameObjects(
    PyObject *,int, PyObject *, PyObject *);
PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithFilename(
    PyObject *exc,
    int ierr,
    const char *filename        /* decoded from the filesystem encoding */
    );
#ifndef Py_LIMITED_API
PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErrWithUnicodeFilename(
    PyObject *,int, const Py_UNICODE *);
#endif
PyAPI_FUNC(PyObject *) PyErr_SetExcFromWindowsErr(PyObject *, int);
#endif /* MS_WINDOWS */

PyAPI_FUNC(PyObject *) PyErr_SetExcWithArgsKwargs(PyObject *, PyObject *,
    PyObject *);
PyAPI_FUNC(PyObject *) PyErr_SetImportError(PyObject *, PyObject *,
    PyObject *);

/* Export the old function so that the existing API remains available: */
PyAPI_FUNC(void) PyErr_BadInternalCall(void);
PyAPI_FUNC(void) _PyErr_BadInternalCall(const char *filename, int lineno);
/* Mask the old API with a call to the new API for code compiled under
   Python 2.0: */
#define PyErr_BadInternalCall() _PyErr_BadInternalCall(__FILE__, __LINE__)

/* Function to create a new exception */
PyAPI_FUNC(PyObject *) PyErr_NewException(
    const char *name, PyObject *base, PyObject *dict);
PyAPI_FUNC(PyObject *) PyErr_NewExceptionWithDoc(
    const char *name, const char *doc, PyObject *base, PyObject *dict);
PyAPI_FUNC(void) PyErr_WriteUnraisable(PyObject *);

/* In exceptions.c */
#ifndef Py_LIMITED_API
/* Helper that attempts to replace the current exception with one of the
 * same type but with a prefix added to the exception text. The resulting
 * exception description looks like:
 *
 *     prefix (exc_type: original_exc_str)
 *
 * Only some exceptions can be safely replaced. If the function determines
 * it isn't safe to perform the replacement, it will leave the original
 * unmodified exception in place.
 *
 * Returns a borrowed reference to the new exception (if any), NULL if the
 * existing exception was left in place.
 */
PyAPI_FUNC(PyObject *) _PyErr_TrySetFromCause(
    const char *prefix_format,   /* ASCII-encoded string  */
    ...
    );
#endif


/* In sigcheck.c or signalmodule.c */
PyAPI_FUNC(int) PyErr_CheckSignals(void);
PyAPI_FUNC(void) PyErr_SetInterrupt(void);

/* In signalmodule.c */
#ifndef Py_LIMITED_API
int PySignal_SetWakeupFd(int fd);
#endif

/* Support for adding program text to SyntaxErrors */
PyAPI_FUNC(void) PyErr_SyntaxLocation(
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno);
PyAPI_FUNC(void) PyErr_SyntaxLocationEx(
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno,
    int col_offset);
#ifndef Py_LIMITED_API
PyAPI_FUNC(void) PyErr_SyntaxLocationObject(
    PyObject *filename,
    int lineno,
    int col_offset);
#endif
PyAPI_FUNC(PyObject *) PyErr_ProgramText(
    const char *filename,       /* decoded from the filesystem encoding */
    int lineno);
#ifndef Py_LIMITED_API
PyAPI_FUNC(PyObject *) PyErr_ProgramTextObject(
    PyObject *filename,
    int lineno);
#endif

/* The following functions are used to create and modify unicode
   exceptions from C */

/* create a UnicodeDecodeError object */
PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_Create(
    const char *encoding,       /* UTF-8 encoded string */
    const char *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    );

/* create a UnicodeEncodeError object */
#ifndef Py_LIMITED_API
PyAPI_FUNC(PyObject *) PyUnicode4   5   6   7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   EncodeError_Create(
    const char *encoding,       /* UTF-8 encoded string */
    const Py_UNICODE *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    );
#endif

/* create a UnicodeTranslateError object */
#ifndef Py_LIMITED_API
PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_Create(
    const Py_UNICODE *object,
    Py_ssize_t length,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    );
PyAPI_FUNC(PyObject *) _PyUnicodeTranslateError_Create(
    PyObject *object,
    Py_ssize_t start,
    Py_ssize_t end,
    const char *reason          /* UTF-8 encoded string */
    );
#endif

/* get the encoding attribute */
PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetEncoding(PyObject *);
PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetEncoding(PyObject *);

/* get the object attribute */
PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetObject(PyObject *);
PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetObject(PyObject *);
PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetObject(PyObject *);

/* get the value of the start attribute (the int * may not be NULL)
   return 0 on success, -1 on failure */
PyAPI_FUNC(int) PyUnicodeEncodeError_GetStart(PyObject *, Py_ssize_t *);
PyAPI_FUNC(int) PyUnicodeDecodeError_GetStart(PyObject *, Py_ssize_t *);
PyAPI_FUNC(int) PyUnicodeTranslateError_GetStart(PyObject *, Py_ssize_t *);

/* assign a new value to the start attribute
   return 0 on success, -1 on failure */
PyAPI_FUNC(int) PyUnicodeEncodeError_SetStart(PyObject *, Py_ssize_t);
PyAPI_FUNC(int) PyUnicodeDecodeError_SetStart(PyObject *, Py_ssize_t);
PyAPI_FUNC(int) PyUnicodeTranslateError_SetStart(PyObject *, Py_ssize_t);

/* get the value of the end attribute (the int *may not be NULL)
 return 0 on success, -1 on failure */
PyAPI_FUNC(int) PyUnicodeEncodeError_GetEnd(PyObject *, Py_ssize_t *);
PyAPI_FUNC(int) PyUnicodeDecodeError_GetEnd(PyObject *, Py_ssize_t *);
PyAPI_FUNC(int) PyUnicodeTranslateError_GetEnd(PyObject *, Py_ssize_t *);

/* assign a new value to the end attribute
   return 0 on success, -1 on failure */
PyAPI_FUNC(int) PyUnicodeEncodeError_SetEnd(PyObject *, Py_ssize_t);
PyAPI_FUNC(int) PyUnicodeDecodeError_SetEnd(PyObject *, Py_ssize_t);
PyAPI_FUNC(int) PyUnicodeTranslateError_SetEnd(PyObject *, Py_ssize_t);

/* get the value of the reason attribute */
PyAPI_FUNC(PyObject *) PyUnicodeEncodeError_GetReason(PyObject *);
PyAPI_FUNC(PyObject *) PyUnicodeDecodeError_GetReason(PyObject *);
PyAPI_FUNC(PyObject *) PyUnicodeTranslateError_GetReason(PyObject *);

/* assign a new value to the reason attribute
   return 0 on success, -1 on failure */
PyAPI_FUNC(int) PyUnicodeEncodeError_SetReason(
    PyObject *exc,
    const char *reason          /* UTF-8 encoded string */
    );
PyAPI_FUNC(int) PyUnicodeDecodeError_SetReason(
    PyObject *exc,
    const char *reason          /* UTF-8 encoded string */
    );
PyAPI_FUNC(int) PyUnicodeTranslateError_SetReason(
    PyObject *exc,
    const char *reason          /* UTF-8 encoded string */
    );

/* These APIs aren't really part of the error implementation, but
   often needed to format error messages; the native C lib APIs are
   not available on all platforms, which is why we provide emulations
   for those platforms in Python/mysnprintf.c,
   WARNING:  The return value of snprintf varies across platforms; do
   not rely on any particular behavior; eventually the C99 defn may
   be reliable.
*/
#if defined(MS_WIN32) && !defined(HAVE_SNPRINTF)
# define HAVE_SNPRINTF
# define snprintf _snprintf
# define vsnprintf _vsnprintf
#endif

#include <stdarg.h>
PyAPI_FUNC(int) PyOS_snprintf(char *str, size_t size, const char  *format, ...)
                        Py_GCC_ATTRIBUTE((format(printf, 3, 4)));
PyAPI_FUNC(int) PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
                        Py_GCC_ATTRIBUTE((format(printf, 3, 0)));

#ifdef __cplusplus
}
#endif
#endif /* !Py_ERRORS_H */
                                                    /* Former class object interface -- now only bound methods are here  */

/* Revealing some structures (not for general use) */

#ifndef Py_LIMITED_API
#ifndef Py_CLASSOBJECT_H
#define Py_CLASSOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    PyObject_HEAD
    PyObject *im_func;   /* The callable object implementing the method */
    PyObject *im_self;   /* The instance it is bound to */
    PyObject *im_weakreflist; /* List of weak references */
} PyMethodObject;

PyAPI_DATA(PyTypeObject) PyMethod_Type;

#define PyMethod_Check(op) ((op)->ob_type == &PyMethod_Type)

PyAPI_FUNC(PyObject *) PyMethod_New(PyObject *, PyObject *);

PyAPI_FUNC(PyObject *) PyMethod_Function(PyObject *);
PyAPI_FUNC(PyObject *) PyMethod_Self(PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
#define PyMethod_GET_FUNCTION(meth) \
        (((PyMethodObject *)meth) -> im_func)
#define PyMethod_GET_SELF(meth) \
	(((PyMethodObject *)meth) -> im_self)

PyAPI_FUNC(int) PyMethod_ClearFreeList(void);

typedef struct {
	PyObject_HEAD
	PyObject *func;
} PyInstanceMethodObject;

PyAPI_DATA(PyTypeObject) PyInstanceMethod_Type;

#define PyInstanceMethod_Check(op) ((op)->ob_type == &PyInstanceMethod_Type)

PyAPI_FUNC(PyObject *) PyInstanceMethod_New(PyObject *);
PyAPI_FUNC(PyObject *) PyInstanceMethod_Function(PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
#define PyInstanceMethod_GET_FUNCTION(meth) \
        (((PyInstanceMethodObject *)meth) -> func)

#ifdef __cplusplus
}
#endif
#endif /* !Py_CLASSOBJECT_H */
#endif /* Py_LIMITED_API */
                                                                                                                                                                                                                                                                                                                                                                                              
/* Capsule objects let you wrap a C "void *" pointer in a Python
   object.  They're a way of passing data through the Python interpreter
   without creating your own custom type.

   Capsules are used for communication between extension modules.
   They provide a way for an extension module to export a C interface
   to other extension modules, so that extension modules can use the
   Python import mechanism to link to one another.

   For more information, please see "c-api/capsule.html" in the
   documentation.
*/

#ifndef Py_CAPSULE_H
#define Py_CAPSULE_H
#ifdef __cplusplus
extern "C" {
#endif

PyAPI_DATA(PyTypeObject) PyCapsule_Type;

typedef void (*PyCapsule_Destructor)(PyObject *);

#define PyCapsule_CheckExact(op) (Py_TYPE(op) == &PyCapsule_Type)


PyAPI_FUNC(PyObject *) PyCapsule_New(
    void *pointer,
    const char *name,
    PyCapsule_Destructor destructor);

PyAPI_FUNC(void *) PyCapsule_GetPointer(PyObject *capsule, const char *name);

PyAPI_FUNC(PyCapsule_Destructor) PyCapsule_GetDestructor(PyObject *capsule);

PyAPI_FUNC(const char *) PyCapsule_GetName(PyObject *capsule);

PyAPI_FUNC(void *) PyCapsule_GetContext(PyObject *capsule);

PyAPI_FUNC(int) PyCapsule_IsValid(PyObject *capsule, const char *name);

PyAPI_FUNC(int) PyCapsule_SetPointer(PyObject *capsule, void *pointer);

PyAPI_FUNC(int) PyCapsule_SetDestructor(PyObject *capsule, PyCapsule_Destructor destructor);

PyAPI_FUNC(int) PyCapsule_SetName(PyObject *capsule, const char *name);

PyAPI_FUNC(int) PyCapsule_SetContext(PyObject *capsule, void *context);

PyAPI_FUNC(void *) PyCapsule_Import(
    const char *name,           /* UTF-8 encoded string */
    int no_block);


#ifdef __cplusplus
}
#endif
#endif /* !Py_CAPSULE_H */
                                                                                                                                                                                                                                                                                                                                  
/* Parse tree node interface */

#ifndef Py_NODE_H
#define Py_NODE_H
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _node {
    short		n_type;
    char		*n_str;
    int			n_lineno;
    int			n_col_offset;
    int			n_nchildren;
    struct _node	*n_child;
} node;

PyAPI_FUNC(node *) PyNode_New(int type);
PyAPI_FUNC(int) PyNode_AddChild(node *n, int type,
                                      char *str, int lineno, int col_offset);
PyAPI_FUNC(void) PyNode_Free(node *n);
#ifndef Py_LIMITED_API
PyAPI_FUNC(Py_ssize_t) _PyNode_SizeOf(node *n);
#endif

/* Node access functions */
#define NCH(n)		((n)->n_nchildren)

#define CHILD(n, i)	(&(n)->n_child[i])
#define RCHILD(n, i)	(CHILD(n, NCH(n) + i))
#define TYPE(n)		((n)->n_type)
#define STR(n)		((n)->n_str)
#define LINENO(n)       ((n)->n_lineno)

/* Assert that the type of a node is what we expect */
#define REQ(n, type) assert(TYPE(n) == (type))

PyAPI_FUNC(void) PyNode_ListTree(node *);

#ifdef __cplusplus
}
#endif
#endif /* !Py_NODE_H */
                 
/* simple namespace object interface */

#ifndef NAMESPACEOBJECT_H
#define NAMESPACEOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

PyAPI_DATA(PyTypeObject) _PyNamespace_Type;

PyAPI_FUNC(PyObject *) _PyNamespace_New(PyObject *kwds);

#ifdef __cplusplus
}
#endif
#endif /* !NAMESPACEOBJECT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
/* Float object interface */

/*
PyFloatObject represents a (double precision) floating point number.
*/

#ifndef Py_FLOATOBJECT_H
#define Py_FLOATOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

#ifndef Py_LIMITED_API
typedef struct {
    PyObject_HEAD
    double ob_fval;
} PyFloatObject;
#endif

PyAPI_DATA(PyTypeObject) PyFloat_Type;

#define PyFloat_Check(op) PyObject_TypeCheck(op, &PyFloat_Type)
#define PyFloat_CheckExact(op) (Py_TYPE(op) == &PyFloat_Type)

#ifdef Py_NAN
#define Py_RETURN_NAN return PyFloat_FromDouble(Py_NAN)
#endif

#define Py_RETURN_INF(sign) do                     \
    if (copysign(1., sign) == 1.) {                \
        return PyFloat_FromDouble(Py_HUGE_VAL);    \
    } else {                        \
        return PyFloat_FromDouble(-Py_HUGE_VAL);   \
    } while(0)

PyAPI_FUNC(double) PyFloat_GetMax(void);
PyAPI_FUNC(double) PyFloat_GetMin(void);
PyAPI_FUNC(PyObject *) PyFloat_GetInfo(void);

/* Return Python float from string PyObject. */
PyAPI_FUNC(PyObject *) PyFloat_FromString(PyObject*);

/* Return Python float from C double. */
PyAPI_FUNC(PyObject *) PyFloat_FromDouble(double);

/* Extract C double from Python float.  The macro version trades safety for
   speed. */
PyAPI_FUNC(double) PyFloat_AsDouble(PyObject *);
#ifndef Py_LIMITED_API
#define PyFloat_AS_DOUBLE(op) (((PyFloatObject *)(op))->ob_fval)
#endif

#ifndef Py_LIMITED_API
/* _PyFloat_{Pack,Unpack}{4,8}
 *
 * The struct and pickle (at least) modules need an efficient platform-
 * independent way to store floating-point values as byte strings.
 * The Pack routines produce a string from a C double, and the Unpack
 * routines produce a C double from such a string.  The suffix (4 or 8)
 * specifies the number of bytes in the string.
 *
 * On platforms that appear to use (see _PyFloat_Init()) IEEE-754 formats
 * these functions work by copying bits.  On other platforms, the formats the
 * 4- byte format is identical to the IEEE-754 single precision format, and
 * the 8-byte format to the IEEE-754 double precision format, although the
 * packing of INFs and NaNs (if such things exist on the platform) isn't
 * handled correctly, and attempting to unpack a string containing an IEEE
 * INF or NaN will raise an exception.
 *
 * On non-IEEE platforms with more precision, or larger dynamic range, than
 * 754 supports, not all values can be packed; on non-IEEE platforms with less
 * precision, or smaller dynamic range, not all values can be unpacked.  What
 * happens in such cases is partly accidental (alas).
 */

/* The pack routines write 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if you want the string in little-endian format (exponent
 * last, at p+3 or p+7), false if you want big-endian format (exponent
 * first, at p).
 * Return value:  0 if all is OK, -1 if error (and an exception is
 * set, most likely OverflowError).
 * There are two problems on non-IEEE platforms:
 * 1):  What this does is undefined if x is a NaN or infinity.
 * 2):  -0.0 and +0.0 produce the same string.
 */
PyAPI_FUNC(int) _PyFloat_Pack4(double x, unsigned char *p, int le);
PyAPI_FUNC(int) _PyFloat_Pack8(double x, unsigned char *p, int le);

/* Needed for the old way for marshal to store a floating point number.
   Returns the string length copied into p, -1 on error.
 */
PyAPI_FUNC(int) _PyFloat_Repr(double x, char *p, size_t len);

/* Used to get the important decimal digits of a double */
PyAPI_FUNC(int) _PyFloat_Digits(char *buf, double v, int *signum);
PyAPI_FUNC(void) _PyFloat_DigitsInit(void);

/* The unpack routines read 4 or 8 bytes, starting at p.  le is a bool
 * argument, true if the string is in little-endian format (exponent
 * last, at p+3 or p+7), false if big-endian (exponent first, at p).
 * Return value:  The unpacked double.  On error, this is -1.0 and
 * PyErr_Occurred() is true (and an exception is set, most likely
 * OverflowError).  Note that on a non-IEEE platform this will refuse
 * to unpack a string that represents a NaN or infinity.
 */
PyAPI_FUNC(double) _PyFloat_Unpack4(const unsigned char *p, int le);
PyAPI_FUNC(double) _PyFloat_Unpack8(const unsigned char *p, int le);

/* free list api */
PyAPI_FUNC(int) PyFloat_ClearFreeList(void);

PyAPI_FUNC(void) _PyFloat_DebugMallocStats(FILE* out);

/* Format the object based on the format_spec, as defined in PEP 3101
   (Advanced String Formatting). */
PyAPI_FUNC(int) _PyFloat_FormatAdvancedWriter(
    _PyUnicodeWriter *writer,
    PyObject *obj,
    PyObject *format_spec,
    Py_ssize_t start,
    Py_ssize_t end);
#endif /* Py_LIMITED_API */

#ifdef __cplusplus
}
#endif
#endif /* !Py_FLOATOBJECT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
/* Generator object interface */

#ifndef Py_LIMITED_API
#ifndef Py_GENOBJECT_H
#define Py_GENOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

struct _frame; /* Avoid including frameobject.h */

/* _PyGenObject_HEAD defines the initial segment of generator
   and coroutine objects. */
#define _PyGenObject_HEAD(prefix)                                           \
    PyObject_HEAD                                                           \
    /* Note: gi_frame can be NULL if the generator is "finished" */         \
    struct _frame *prefix##_frame;                                          \
    /* True if generator is being executed. */                              \
    char prefix##_running;                                                  \
    /* The code object backing the generator */                             \
    PyObject *prefix##_code;                                                \
    /* List of weak reference. */                                           \
    PyObject *prefix##_weakreflist;                                         \
    /* Name of the generator. */                                            \
    PyObject *prefix##_name;                                                \
    /* Qualified name of the generator. */                                  \
    PyObject *prefix##_qualname;

typedef struct {
    /* The gi_ prefix is intended to remind of generator-iterator. */
    _PyGenObject_HEAD(gi)
} PyGenObject;

PyAPI_DATA(PyTypeObject) PyGen_Type;

#define PyGen_Check(op) PyObject_TypeCheck(op, &PyGen_Type)
#define PyGen_CheckExact(op) (Py_TYPE(op) == &PyGen_Type)

PyAPI_FUNC(PyObject *) PyGen_New(struct _frame *);
PyAPI_FUNC(PyObject *) PyGen_NewWithQualName(struct _frame *,
    PyObject *name, PyObject *qualname);
PyAPI_FUNC(int) PyGen_NeedsFinalizing(PyGenObject *);
PyAPI_FUNC(int) _PyGen_FetchStopIterationValue(PyObject **);
PyObject *_PyGen_Send(PyGenObject *, PyObject *);
PyAPI_FUNC(void) _PyGen_Finalize(PyObject *self);

#ifndef Py_LIMITED_API
typedef struct {
    _PyGenObject_HEAD(cr)
} PyCoroObject;

PyAPI_DATA(PyTypeObject) PyCoro_Type;
PyAPI_DATA(PyTypeObject) _PyCoroWrapper_Type;

#define PyCoro_CheckExact(op) (Py_TYPE(op) == &PyCoro_Type)
PyObject *_PyCoro_GetAwaitableIter(PyObject *o);
PyAPI_FUNC(PyObject *) PyCoro_New(struct _frame *,
    PyObject *name, PyObject *qualname);
#endif

#undef _PyGenObject_HEAD

#ifdef __cplusplus
}
#endif
#endif /* !Py_GENOBJECT_H */
#endif /* Py_LIMITED_API */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 #ifndef Py_ABSTRACTOBJECT_H
#define Py_ABSTRACTOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

#ifdef PY_SSIZE_T_CLEAN
#define PyObject_CallFunction _PyObject_CallFunction_SizeT
#define PyObject_CallMethod _PyObject_CallMethod_SizeT
#define _PyObject_CallMethodId _PyObject_CallMethodId_SizeT
#endif

/* Abstract Object Interface (many thanks to Jim Fulton) */

/*
   PROPOSAL: A Generic Python Object Interface for Python C Modules

Problem

  Python modules written in C that must access Python objects must do
  so through routines whose interfaces are described by a set of
  include files.  Unfortunately, these routines vary according to the
  object accessed.  To use these routines, the C programmer must check
  the type of the object being used and must call a routine based on
  the object type.  For example, to access an element of a sequence,
  the programmer must determine whether the sequence is a list or a
  tuple:

    if(is_tupleobject(o))
      e=gettupleitem(o,i)
    else if(is_listitem(o))
      e=getlistitem(o,i)

  If the programmer wants to get an item from another type of object
  that provides sequence behavior, there is no clear way to do it
  correctly.

  The persistent programmer may peruse object.h and find that the
  _typeobject structure provides a means of invoking up to (currently
  about) 41 special operators.  So, for example, a routine can get an
  item from any object that provides sequence behavior. However, to
  use this mechanism, the programmer must make their code dependent on
  the current Python implementation.

  Also, certain semantics, especially memory management semantics, may
  differ by the type of object being used.  Unfortunately, these
  semantics are not clearly described in the current include files.
  An abstract interface providing more consistent semantics is needed.

Proposal

  I propose the creation of a standard interface (with an associated
  library of routines and/or macros) for generically obtaining the
  services of Python objects.  This proposal can be viewed as one
  components of a Python C interface consisting of several components.

  From the viewpoint of C access to Python services, we have (as
  suggested by Guido in off-line discussions):

  - "Very high level layer": two or three functions that let you exec or
    eval arbitrary Python code given as a string in a module whose name is
    given, passing C values in and getting C values out using
    mkvalue/getargs style format strings.  This does not require the user
    to declare any variables of type "PyObject *".  This should be enough
    to write a simple application that gets Python code from the user,
    execs it, and returns the output or errors.  (Error handling must also
    be part of this API.)

  - "Abstract objects layer": which is the subject of this proposal.
    It has many functions operating on objects, and lest you do many
    things from C that you can also write in Python, without going
    through the Python parser.

  - "Concrete objects layer": This is the public type-dependent
    interface provided by the standard built-in types, such as floats,
    strings, and lists.  This interface exists and is currently
    documented by the collection of include files provided with the
    Python distributions.

  From the point of view of Python accessing services provided by C
  modules:

  - "Python module interface": this interface consist of the basic
    routines used to define modules and their members.  Most of the
    current extensions-writing guide deals with this interface.

  - "Built-in object interface": this is the interface that a new
    built-in type must provide and the mechanisms and rules that a
    developer of a new built-in type must use and follow.

  This proposal is a "first-cut" that is intended to spur
  discussion. See especially the lists of notes.

  The Python C object interface will provide four protocols: object,
  numeric, sequence, and mapping.  Each protocol consists of a
  collection of related operations.  If an operation that is not
  provided by a particular type is invoked, then a standard exception,
  NotImplementedError is raised with an operation name as an argument.
  In addition, for convenience this interface defines a set of
  constructors for building objects of built-in types.  This is needed
  so new objects can be returned from C functions that otherwise treat
  objects generically.

Memory Management

  For all of the functions described in this proposal, if a function
  retains a reference to a Python object passed as an argument, then the
  function will increase the reference count of the object.  It is
  unnecessary for the caller to increase the reference count of an
  argument in anticipation of the object's retention.

  All Python objects returned from functions should be treated as new
  objects.  Functions that return objects assume that the caller will
  retain a reference and the reference count of the object has already
  been incremented to account for this fact.  A caller that does not
  retain a reference to an object that is returned from a function
  must decrement the reference count of the object (using
  DECREF(object)) to prevent memory leaks.

  Note that the behavior mentioned here is different from the current
  behavior for some objects (e.g. lists and tuples) when certain
  type-specific routines are called directly (e.g. setlistitem).  The
  proposed abstraction layer will provide a consistent memory
  management interface, correcting for inconsistent behavior for some
  built-in types.

Protocols

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/

/*  Object Protocol: */

     /* Implemented elsewhere:

     int PyObject_Print(PyObject *o, FILE *fp, int flags);

     Print an object, o, on file, fp.  Returns -1 on
     error.  The flags argument is used to enable certain printing
     options. The only option currently supported is Py_Print_RAW.

     (What should be said about Py_Print_RAW?)

       */

     /* Implemented elsewhere:

     int PyObject_HasAttrString(PyObject *o, const char *attr_name);

     Returns 1 if o has the attribute attr_name, and 0 otherwise.
     This is equivalent to the Python expression:
     hasattr(o,attr_name).

     This function always succeeds.

       */

     /* Implemented elsewhere:

     PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name);

     Retrieve an attributed named attr_name form object o.
     Returns the attribute value on success, or NULL on failure.
     This is the equivalent of the Python expression: o.attr_name.

       */

     /* Implemented elsewhere:

     int PyObject_HasAttr(PyObject *o, PyObject *attr_name);

     Returns 1 if o has the attribute attr_name, and 0 otherwise.
     This is equivalent to the Python expression:
     hasattr(o,attr_name).

     This function always succeeds.

       */

     /* Implemented elsewhere:

     PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name);

     Retrieve an attributed named attr_name form object o.
     Returns the attribute value on success, or NULL on failure.
     This is the equivalent of the Python expression: o.attr_name.

       */


     /* Implemented elsewhere:

     int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v);

     Set the value of the attribute named attr_name, for object o,
     to the value, v. Returns -1 on failure.  This is
     the equivalent of the Python statement: o.attr_name=v.

       */

     /* Implemented elsewhere:

     int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v);

     Set the value of the attribute named attr_name, for object o,
     to the value, v. Returns -1 on failure.  This is
     the equivalent of the Python statement: o.attr_name=v.

       */

     /* implemented as a macro:

     int PyObject_DelAttrString(PyObject *o, const char *attr_name);

     Delete attribute named attr_name, for object o. Returns
     -1 on failure.  This is the equivalent of the Python
     statement: del o.attr_name.

       */
#define  PyObject_DelAttrString(O,A) PyObject_SetAttrString((O),(A),NULL)

     /* implemented as a macro:

     int PyObject_DelAttr(PyObject *o, PyObject *attr_name);

     Delete attribute named attr_name, for object o. Returns -1
     on failure.  This is the equivalent of the Python
     statement: del o.attr_name.

       */
#define  PyObject_DelAttr(O,A) PyObject_SetAttr((O),(A),NULL)

     /* Implemented elsewhere:

     PyObject *PyObject_Repr(PyObject *o);

     Compute the string representation of object, o.  Returns the
     string representation on success, NULL on failure.  This is
     the equivalent of the Python expression: repr(o).

     Called by the repr() built-in function.

       */

     /* Implemented elsewhere:

     PyObject *PyObject_Str(PyObject *o);

     Compute the string representation of object, o.  Returns the
     string representation on success, NULL on failure.  This is
     the equivalent of the Python expression: str(o).)

     Called by the str() and print() built-in functions.

       */

       /* Declared elsewhere

     PyAPI_FUNC(int) PyCallable_Check(PyObject *o);

     Determine if the object, o, is callable.  Return 1 if the
     object is callable and 0 otherwise.

     This function always succeeds.
       */

     PyAPI_FUNC(PyObject *) PyObject_Call(PyObject *callable_object,
                                          PyObject *args, PyObject *kw);

#ifndef Py_LIMITED_API
     PyAPI_FUNC(PyObject *) _Py_CheckFunctionResult(PyObject *func,
                                                    PyObject *result,
                                                    const char *where);
#endif

       /*
     Call a callable Python object, callable_object, with
     arguments and keywords arguments.  The 'args' argument can not be
     NULL, but the 'kw' argument can be NULL.
       */

     PyAPI_FUNC(PyObject *) PyObject_CallObject(PyObject *callable_object,
                                                PyObject *args);

       /*
     Call a callable Python object, callable_object, with
     arguments given by the tuple, args.  If no arguments are
     needed, then args may be NULL.  Returns the result of the
     call on success, or NULL on failure.  This is the equivalent
     of the Python expression: o(*args).
       */

     PyAPI_FUNC(PyObject *) PyObject_CallFunction(PyObject *callable_object,
                                                  const char *format, ...);

       /*
     Call a callable Python object, callable_object, with a
     variable number of C arguments. The C arguments are described
     using a mkvalue-style format string. The format may be NULL,
     indicating that no arguments are provided.  Returns the
     result of the call on success, or NULL on failure.  This is
     the equivalent of the Python expression: o(*args).
       */


     PyAPI_FUNC(PyObject *) PyObject_CallMethod(PyObject *o,
                                                const char *method,
                                                const char *format, ...);

       /*
     Call the method named m of object o with a variable number of
     C arguments.  The C arguments are described by a mkvalue
     format string.  The format may be NULL, indicating that no
     arguments are provided. Returns the result of the call on
     success, or NULL on failure.  This is the equivalent of the
     Python expression: o.method(args).
       */

     PyAPI_FUNC(PyObject *) _PyObject_CallMethodId(PyObject *o,
                                                   _Py_Identifier *method,
                                                   const char *format, ...);

       /*
         Like PyObject_CallMethod, but expect a _Py_Identifier* as the
         method name.
       */

     PyAPI_FUNC(PyObject *) _PyObject_CallFunction_SizeT(PyObject *callable,
                                                         const char *format,
                                                         ...);
     PyAPI_FUNC(PyObject *) _PyObject_CallMethod_SizeT(PyObject *o,
                                                       const char *name,
                S   T   U   V   W   X   Y   Z   [   \   ]   ^   _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              const char *format,
                                                       ...);
     PyAPI_FUNC(PyObject *) _PyObject_CallMethodId_SizeT(PyObject *o,
                                                       _Py_Identifier *name,
                                                       const char *format,
                                                       ...);

     PyAPI_FUNC(PyObject *) PyObject_CallFunctionObjArgs(PyObject *callable,
                                                         ...);

       /*
     Call a callable Python object, callable_object, with a
     variable number of C arguments.  The C arguments are provided
     as PyObject * values, terminated by a NULL.  Returns the
     result of the call on success, or NULL on failure.  This is
     the equivalent of the Python expression: o(*args).
       */


     PyAPI_FUNC(PyObject *) PyObject_CallMethodObjArgs(PyObject *o,
                                                       PyObject *method, ...);
     PyAPI_FUNC(PyObject *) _PyObject_CallMethodIdObjArgs(PyObject *o,
                                               struct _Py_Identifier *method,
                                               ...);

       /*
     Call the method named m of object o with a variable number of
     C arguments.  The C arguments are provided as PyObject *
     values, terminated by NULL.  Returns the result of the call
     on success, or NULL on failure.  This is the equivalent of
     the Python expression: o.method(args).
       */


     /* Implemented elsewhere:

     long PyObject_Hash(PyObject *o);

     Compute and return the hash, hash_value, of an object, o.  On
     failure, return -1.  This is the equivalent of the Python
     expression: hash(o).
       */


     /* Implemented elsewhere:

     int PyObject_IsTrue(PyObject *o);

     Returns 1 if the object, o, is considered to be true, 0 if o is
     considered to be false and -1 on failure. This is equivalent to the
     Python expression: not not o
       */

     /* Implemented elsewhere:

     int PyObject_Not(PyObject *o);

     Returns 0 if the object, o, is considered to be true, 1 if o is
     considered to be false and -1 on failure. This is equivalent to the
     Python expression: not o
       */

     PyAPI_FUNC(PyObject *) PyObject_Type(PyObject *o);

       /*
     On success, returns a type object corresponding to the object
     type of object o. On failure, returns NULL.  This is
     equivalent to the Python expression: type(o).
       */

     PyAPI_FUNC(Py_ssize_t) PyObject_Size(PyObject *o);

       /*
     Return the size of object o.  If the object, o, provides
     both sequence and mapping protocols, the sequence size is
     returned. On error, -1 is returned.  This is the equivalent
     to the Python expression: len(o).
       */

       /* For DLL compatibility */
#undef PyObject_Length
     PyAPI_FUNC(Py_ssize_t) PyObject_Length(PyObject *o);
#define PyObject_Length PyObject_Size

#ifndef Py_LIMITED_API
     PyAPI_FUNC(int) _PyObject_HasLen(PyObject *o);
     PyAPI_FUNC(Py_ssize_t) PyObject_LengthHint(PyObject *o, Py_ssize_t);
#endif

       /*
     Guess the size of object o using len(o) or o.__length_hint__().
     If neither of those return a non-negative value, then return the
     default value.  If one of the calls fails, this function returns -1.
       */

     PyAPI_FUNC(PyObject *) PyObject_GetItem(PyObject *o, PyObject *key);

       /*
     Return element of o corresponding to the object, key, or NULL
     on failure. This is the equivalent of the Python expression:
     o[key].
       */

     PyAPI_FUNC(int) PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v);

       /*
     Map the object, key, to the value, v.  Returns
     -1 on failure.  This is the equivalent of the Python
     statement: o[key]=v.
       */

     PyAPI_FUNC(int) PyObject_DelItemString(PyObject *o, const char *key);

       /*
     Remove the mapping for object, key, from the object *o.
     Returns -1 on failure.  This is equivalent to
     the Python statement: del o[key].
       */

     PyAPI_FUNC(int) PyObject_DelItem(PyObject *o, PyObject *key);

       /*
     Delete the mapping for key from *o.  Returns -1 on failure.
     This is the equivalent of the Python statement: del o[key].
       */

    /* old buffer API
       FIXME:  usage of these should all be replaced in Python itself
       but for backwards compatibility we will implement them.
       Their usage without a corresponding "unlock" mechansim
       may create issues (but they would already be there). */

     PyAPI_FUNC(int) PyObject_AsCharBuffer(PyObject *obj,
                                           const char **buffer,
                                           Py_ssize_t *buffer_len);

       /*
      Takes an arbitrary object which must support the (character,
      single segment) buffer interface and returns a pointer to a
      read-only memory location useable as character based input
      for subsequent processing.

      0 is returned on success.  buffer and buffer_len are only
      set in case no error occurs. Otherwise, -1 is returned and
      an exception set.
       */

     PyAPI_FUNC(int) PyObject_CheckReadBuffer(PyObject *obj);

      /*
      Checks whether an arbitrary object supports the (character,
      single segment) buffer interface.  Returns 1 on success, 0
      on failure.
      */

     PyAPI_FUNC(int) PyObject_AsReadBuffer(PyObject *obj,
                                           const void **buffer,
                                           Py_ssize_t *buffer_len);

       /*
      Same as PyObject_AsCharBuffer() except that this API expects
      (readable, single segment) buffer interface and returns a
      pointer to a read-only memory location which can contain
      arbitrary data.

      0 is returned on success.  buffer and buffer_len are only
      set in case no error occurs.  Otherwise, -1 is returned and
      an exception set.
       */

     PyAPI_FUNC(int) PyObject_AsWriteBuffer(PyObject *obj,
                                            void **buffer,
                                            Py_ssize_t *buffer_len);

       /*
      Takes an arbitrary object which must support the (writable,
      single segment) buffer interface and returns a pointer to a
      writable memory location in buffer of size buffer_len.

      0 is returned on success.  buffer and buffer_len are only
      set in case no error occurs. Otherwise, -1 is returned and
      an exception set.
       */

    /* new buffer API */

#ifndef Py_LIMITED_API
#define PyObject_CheckBuffer(obj) \
    (((obj)->ob_type->tp_as_buffer != NULL) &&  \
     ((obj)->ob_type->tp_as_buffer->bf_getbuffer != NULL))

    /* Return 1 if the getbuffer function is available, otherwise
       return 0 */

     PyAPI_FUNC(int) PyObject_GetBuffer(PyObject *obj, Py_buffer *view,
                                        int flags);

    /* This is a C-API version of the getbuffer function call.  It checks
       to make sure object has the required function pointer and issues the
       call.  Returns -1 and raises an error on failure and returns 0 on
       success
    */


     PyAPI_FUNC(void *) PyBuffer_GetPointer(Py_buffer *view, Py_ssize_t *indices);

    /* Get the memory area pointed to by the indices for the buffer given.
       Note that view->ndim is the assumed size of indices
    */

     PyAPI_FUNC(int) PyBuffer_SizeFromFormat(const char *);

    /* Return the implied itemsize of the data-format area from a
       struct-style description */



     /* Implementation in memoryobject.c */
     PyAPI_FUNC(int) PyBuffer_ToContiguous(void *buf, Py_buffer *view,
                                           Py_ssize_t len, char order);

     PyAPI_FUNC(int) PyBuffer_FromContiguous(Py_buffer *view, void *buf,
                                             Py_ssize_t len, char order);


    /* Copy len bytes of data from the contiguous chunk of memory
       pointed to by buf into the buffer exported by obj.  Return
       0 on success and return -1 and raise a PyBuffer_Error on
       error (i.e. the object does not have a buffer interface or
       it is not working).

       If fort is 'F', then if the object is multi-dimensional,
       then the data will be copied into the array in
       Fortran-style (first dimension varies the fastest).  If
       fort is 'C', then the data will be copied into the array
       in C-style (last dimension varies the fastest).  If fort
       is 'A', then it does not matter and the copy will be made
       in whatever way is more efficient.

    */

     PyAPI_FUNC(int) PyObject_CopyData(PyObject *dest, PyObject *src);

    /* Copy the data from the src buffer to the buffer of destination
     */

     PyAPI_FUNC(int) PyBuffer_IsContiguous(const Py_buffer *view, char fort);


     PyAPI_FUNC(void) PyBuffer_FillContiguousStrides(int ndims,
                                                    Py_ssize_t *shape,
                                                    Py_ssize_t *strides,
                                                    int itemsize,
                                                    char fort);

    /*  Fill the strides array with byte-strides of a contiguous
        (Fortran-style if fort is 'F' or C-style otherwise)
        array of the given shape with the given number of bytes
        per element.
    */

     PyAPI_FUNC(int) PyBuffer_FillInfo(Py_buffer *view, PyObject *o, void *buf,
                                       Py_ssize_t len, int readonly,
                                       int flags);

    /* Fills in a buffer-info structure correctly for an exporter
       that can only share a contiguous chunk of memory of
       "unsigned bytes" of the given length. Returns 0 on success
       and -1 (with raising an error) on error.
     */

     PyAPI_FUNC(void) PyBuffer_Release(Py_buffer *view);

       /* Releases a Py_buffer obtained from getbuffer ParseTuple's s*.
    */
#endif /* Py_LIMITED_API */

     PyAPI_FUNC(PyObject *) PyObject_Format(PyObject* obj,
                                            PyObject *format_spec);
       /*
     Takes an arbitrary object and returns the result of
     calling obj.__format__(format_spec).
       */

/* Iterators */

     PyAPI_FUNC(PyObject *) PyObject_GetIter(PyObject *);
     /* Takes an object and returns an iterator for it.
    This is typically a new iterator but if the argument
    is an iterator, this returns itself. */

#define PyIter_Check(obj) \
    ((obj)->ob_type->tp_iternext != NULL && \
     (obj)->ob_type->tp_iternext != &_PyObject_NextNotImplemented)

     PyAPI_FUNC(PyObject *) PyIter_Next(PyObject *);
     /* Takes an iterator object and calls its tp_iternext slot,
    returning the next value.  If the iterator is exhausted,
    this returns NULL without setting an exception.
    NULL with an exception means an error occurred. */

/*  Number Protocol:*/

     PyAPI_FUNC(int) PyNumber_Check(PyObject *o);

       /*
     Returns 1 if the object, o, provides numeric protocols, and
     false otherwise.

     This function always succeeds.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Add(PyObject *o1, PyObject *o2);

       /*
     Returns the result of adding o1 and o2, or null on failure.
     This is the equivalent of the Python expression: o1+o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Subtract(PyObject *o1, PyObject *o2);

       /*
     Returns the result of subtracting o2 from o1, or null on
     failure.  This is the equivalent of the Python expression:
     o1-o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Multiply(PyObject *o1, PyObject *o2);

       /*
     Returns the result of multiplying o1 and o2, or null on
     failure.  This is the equivalent of the Python expression:
     o1*o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2);

       /*
     This is the equivalent of the Python expression: o1 @ o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_FloorDivide(PyObject *o1, PyObject *o2);

       /*
     Returns the result of dividing o1 by o2 giving an integral result,
     or null on failure.
     This is the equivalent of the Python expression: o1//o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_TrueDivide(PyObject *o1, PyObject *o2);

       /*
     Returns the result of dividing o1 by o2 giving a float result,
     or null on failure.
     This is the equivalent of the Python expression: o1/o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Remainder(PyObject *o1, PyObject *o2);

       /*
     Returns the remainder of dividing o1 by o2, or null on
     failure.  This is the equivalent of the Python expression:
     o1%o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Divmod(PyObject *o1, PyObject *o2);

       /*
     See the built-in function divmod.  Returns NULL on failure.
     This is the equivalent of the Python expression:
     divmod(o1,o2).
       */

     PyAPI_FUNC(PyObject *) PyNumber_Power(PyObject *o1, PyObject *o2,
                                           PyObject *o3);

       /*
     See the built-in function pow.  Returns NULL on failure.
     This is the equivalent of the Python expression:
     pow(o1,o2,o3), where o3 is optional.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Negative(PyObject *o);

       /*
     Returns the negation of o on success, or null on failure.
     This is the equivalent of the Python expression: -o.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Positive(PyObject *o);

       /*
     Returns the (what?) of o on success, or NULL on failure.
     This is the equivalent of the Python expression: +o.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Absolute(PyObject *o);

       /*
     Returns the absolute value of o, or null on failure.  This is
     the equivalent of the Python expression: abs(o).
       */

     PyAPI_FUNC(PyObject *) PyNumber_Invert(PyObject *o);

       /*
     Returns the bitwise negation of o on success, or NULL on
     failure.  This is the equivalent of the Python expression:
     ~o.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Lshift(PyObject *o1, PyObject *o2);

       /*
     Returns the result of left shifting o1 by o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1 << o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Rshift(PyObject *o1, PyObject *o2);

       /*
     Returns the result of right shifting o1 by o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1 >> o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_And(PyObject *o1, PyObject *o2);

       /*
     Returns the result of bitwise and of o1 and o2 on success, or
     NULL on failure. This is the equivalent of the Python
     expression: o1&o2.

       */

     PyAPI_FUNC(PyObject *) PyNumber_Xor(PyObject *o1, PyObject *o2);

       /*
     Returns the bitwise exclusive or of o1 by o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1^o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Or(PyObject *o1, PyObject *o2);

       /*
     Returns the result of bitwise or on o1 and o2 on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: o1|o2.
       */

#define PyIndex_Check(obj) \
   ((obj)->ob_type->tp_as_number != NULL && \
    (obj)->ob_type->tp_as_number->nb_index != NULL)

     PyAPI_FUNC(PyObject *) PyNumber_Index(PyObject *o);

       /*
     Returns the object converted to a Python int
     or NULL with an error raised on failure.
       */

     PyAPI_FUNC(Py_ssize_t) PyNumber_AsSsize_t(PyObject *o, PyObject *exc);

       /*
    Returns the object converted to Py_ssize_t by going through
    PyNumber_Index first.  If an overflow error occurs while
    converting the int to Py_ssize_t, then the second argument
    is the error-type to return.  If it is NULL, then the overflow error
    is cleared and the value is clipped.
       */

     PyAPI_FUNC(PyObject *) PyNumber_Long(PyObject *o);

       /*
     Returns the o converted to an integer object on success, or
     NULL on failure.  This is the equivalent of the Python
     expression: int(o).
       */

     PyAPI_FUNC(PyObject *) PyNumber_Float(PyObject *o);

       /*
     Returns the o converted to a float object on success, or NULL
     on failure.  This is the equivalent of the Python expression:
     float(o).
       */

/*  In-place variants of (some of) the above number protocol functions */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2);

       /*
     Returns the result of adding o2 to o1, possibly in-place, or null
     on failure.  This is the equivalent of the Python expression:
     o1 += o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2);

       /*
     Returns the result of subtracting o2 from o1, possibly in-place or
     null on failure.  This is the equivalent of the Python expression:
     o1 -= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2);

       /*
     Returns the result of multiplying o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 *= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2);

       /*
     This is the equivalent of the Python expression: o1 @= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceFloorDivide(PyObject *o1,
                                                        PyObject *o2);

       /*
     Returns the result of dividing o1 by o2 giving an integral result,
     possibly in-place, or null on failure.
     This is the equivalent of the Python expression:
     o1 /= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceTrueDivide(PyObject *o1,
                                                       PyObject *o2);

       /*
     Returns the result of dividing o1 by o2 giving a float result,
     possibly in-place, or null on failure.
     This is the equivalent of the Python expression:
     o1 /= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2);

       /*
     Returns the remainder of dividing o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 %= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlacePower(PyObject *o1, PyObject *o2,
                                                  PyObject *o3);

       /*
     Returns the result of raising o1 to the power of o2, possibly
     in-place, or null on failure.  This is the equivalent of the Python
     expression: o1 **= o2, or pow(o1, o2, o3) if o3 is present.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2);

       /*
     Returns the result of left shifting o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 <<= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2);

       /*
     Returns the result of right shifting o1 by o2, possibly in-place or
     null on failure.  This is the equivalent of the Python expression:
     o1 >>= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2);

       /*
     Returns the result of bitwise and of o1 and o2, possibly in-place,
     or null on failure. This is the equivalent of the Python
     expression: o1 &= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceXor(PyObject *o1, PyObject *o2);

       /*
     Returns the bitwise exclusive or of o1 by o2, possibly in-place, or
     null on failure.  This is the equivalent of the Python expression:
     o1 ^= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_InPlaceOr(PyObject *o1, PyObject *o2);

       /*
     Returns the result of bitwise or of o1 and o2, possibly in-place,
     or null on failure.  This is the equivalent of the Python
     expression: o1 |= o2.
       */

     PyAPI_FUNC(PyObject *) PyNumber_ToBase(PyObject *n, int base);

       /*
     Returns the integer n converted to a string with a base, with a base
     marker of 0b, 0o or 0x prefixed if applicable.
     If n is not an int object, it is converted with PyNumber_Index first.
       */


/*  Sequence protocol:*/

     PyAPI_FUNC(int) PySequence_Check(PyObject *o);

       /*
     Return 1 if the object provides sequence protocol, and zero
     otherwise.

     This function always succeeds.
       */

     PyAPI_FUNC(Py_ssize_t) PySequence_Size(PyObject *o);

       /*
     Return the size of sequence object o, or -1 on failure.
       */

       /* For DLL compatibility */
#undef PySequence_Length
     PyAPI_FUNC(Py_ssize_t) PySequence_Length(PyObject *o);
#define PySequence_Length PySequence_Size


     PyAPI_FUNC(PyObject *) PySequence_Concat(PyObject *o1, PyObject *o2);

       /*
     Return the concatenation of o1 and o2 on success, and NULL on
     failure.   This is the equivalent of the Python
     expression: o1+o2.
       */

     PyAPI_FUNC(PyObject *) PySequence_Repeat(PyObject *o, Py_ssize_t count);

       /*
     Return the result of repeating sequence object o count times,
     or NULL on failure.  This is the equivalent of the Python
     expression: o1*count.
       */

     PyAPI_FUNC(PyObject *) PySequence_GetItem(PyObject *o, Py_ssize_t i);

       /*
     Return the ith element of o, or NULL on failure. This is the
     equivalent of the Python expression: o[i].
       */

     PyAPI_FUNC(PyObject *) PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);

       /*
     Return the slice of sequence object o between i1 and i2, or
     NULL on failure. This is the equivalent of the Python
     expression: o[i1:i2].
       */

     PyAPI_FUNC(int) PySequence_SetItem(PyObject *o, Py_ssize_t i, PyObject *v);

       /*
     Assign object v to the ith element of o.  Returns
     -1 on failure.  This is the equivalent of the Python
     statement: o[i]=v.
       */

     PyAPI_FUNC(int) PySequence_DelItem(PyObject *o, Py_ssize_t i);

       /*
     Delete the ith element of object v.  Returns
     -1 on failure.  This is the equivalent of the Python
     statement: del o[i].
       */

     PyAPI_FUNC(int) PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2,
                                         PyObject *v);

       /*
     Assign the sequence object, v, to the slice in sequence
     object, o, from i1 to i2.  Returns -1 on failure. This is the
     equivalent of the Python statement: o[i1:i2]=v.
       */

     PyAPI_FUNC(int) PySequence_DelSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2);

       /*
     Delete the slice in sequence object, o, from i1 to i2.
     Returns -1 on failure. This is the equivalent of the Python
     statement: del o[i1:i2].
       */

     PyAPI_FUNC(PyObject *) PySequence_Tuple(PyObject *o);

       /*
     Returns the sequence, o, as a tuple on success, and NULL on failure.
     This is equivalent to the Python expression: tuple(o)
       */


     PyAPI_FUNC(PyObject *) PySequence_List(PyObject *o);
       /*
     Returns the sequence, o, as a list on success, and NULL on failure.
     This is equivalent to the Python expression: list(o)
       */

     PyAPI_FUNC(PyObject *) PySequence_Fast(PyObject *o, const char* m);
       /*
     Return the sequence, o, as a list, unless it's already a
     tuple or list.  Use PySequence_Fast_GET_ITEM to access the
     members of this list, and PySequence_Fast_GET_SIZE to get its length.

     Returns NULL on failure.  If the object does not support iteration,
     raises a TypeError exception with m as the message text.
       */

#define PySequence_Fast_GET_SIZE(o) \
    (PyList_Check(o) ? PyList_GET_SIZE(o) : PyTuple_GET_SIZE(o))
       /*
     Return the size of o, assuming that o was returned by
     PySequence_Fast and is not NULL.
       */

#define PySequence_Fast_GET_ITEM(o, i)\
     (PyList_Check(o) ? PyList_GET_ITEM(o, i) : PyTuple_GET_ITEM(o, i))
       /*
     Return the ith element of o, assuming that o was returned by
     PySequence_Fast, and that i is within bounds.
       */

#define PySequence_ITEM(o, i)\
    ( Py_TYPE(o)->tp_as_sequence->sq_item(o, i) )
       /* Assume tp_as_sequence and sq_item exist and that i does not
      need to be corrected for a negative index
       */

#define PySequence_Fast_ITEMS(sf) \
    (PyList_Check(sf) ? ((PyListObject *)(sf))->ob_item \
                      : ((PyTupleObject *)(sf))->ob_item)
    /* Return a pointer to the underlying item array for
       an object retured by PySequence_Fast */

     PyAPI_FUNC(Py_ssize_t) PySequence_Count(PyObject *o, PyObject *value);

       /*
     Return the number of occurrences on value on o, that is,
     return the number of keys for which o[key]==value.  On
     failure, return -1.  This is equivalent to the Python
     expression: o.count(value).
       */

     PyAPI_FUNC(int) PySequence_Contains(PyObject *seq, PyObject *ob);
       /*
     Return -1 if error; 1 if ob in seq; 0 if ob not in seq.
     Use __contains__ if possible, else _PySequence_IterSearch().
       */

#ifndef Py_LIMITED_API
#define PY_ITERSEARCH_COUNT    1
#define PY_ITERSEARCH_INDEX    2
#define PY_ITERSEARCH_CONTAINS 3
     PyAPI_FUNC(Py_ssize_t) _PySequence_IterSearch(PyObject *seq,
                                        PyObject *obj, int operation);
#endif
    /*
      Iterate over seq.  Result depends on the operation:
      PY_ITERSEARCH_COUNT:  return # of times obj appears in seq; -1 if
        error.
      PY_ITERSEARCH_INDEX:  return 0-based index of first occurrence of
        obj in seq; set ValueError and return -1 if none found;
        also return -1 on error.
      PY_ITERSEARCH_CONTAINS:  return 1 if obj in seq, else 0; -1 on
        error.
    */

/* For DLL-level backwards compatibility */
#undef PySequence_In
     PyAPI_FUNC(int) PySequence_In(PyObject *o, PyObject *value);

/* For source-level backwards compatibility */
#define PySequence_In PySequence_Contains

       /*
     Determine if o contains value.  If an item in o is equal to
     X, return 1, otherwise return 0.  On error, return -1.  This
     is equivalent to the Python expression: value in o.
       */

     PyAPI_FUNC(Py_ssize_t) PySequence_Index(PyObject *o, PyObject *value);

       /*
     Return the first index for which o[i]=value.  On error,
     return -1.    This is equivalent to the Python
     expression: o.index(value).
       */

/* In-place versions of some of the above Sequence functions. */

     PyAPI_FUNC(PyObject *) PySequence_InPlaceConcat(PyObject *o1, PyObject *o2);

       /*
     Append o2 to o1, in-place when possible. Return the resulting
     object, which could be o1, or NULL on failure.  This is the
     equivalent of the Python expression: o1 += o2.

       */

     PyAPI_FUNC(PyObject *) PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count);

       /*
     Repeat o1 by count, in-place when possible. Return the resulting
     object, which could be o1, or NULL on failure.  This is the
     equivalent of the Python expression: o1 *= count.

       */

/*  Mapping protocol:*/

     PyAPI_FUNC(int) PyMapping_Check(PyObject *o);

       /*
     Return 1 if the object provides mapping protocol, and zero
     otherwise.

     This function always succeeds.
       */

     PyAPI_FUNC(Py_ssize_t) PyMapping_Size(PyObject *o);

       /*
     Returns the number of keys in object o on success, and -1 on
     failure.  For objects that do not provide sequence protocol,
     this is equivalent to the Python expression: len(o).
       */

       /* For DLL compatibility */
#undef PyMapping_Length
     PyAPI_FUNC(Py_ssize_t) PyMapping_Length(PyObject *o);
#define PyMapping_Length PyMapping_Size


     /* implemented as a macro:

     int PyMapping_DelItemString(PyObject *o, const char *key);

     Remove the mapping for object, key, from the object *o.
     Returns -1 on failure.  This is equivalent to
     the Python statement: del o[key].
       */
#define PyMapping_DelItemString(O,K) PyObject_DelItemString((O),(K))

     /* implemented as a macro:

     int PyMapping_DelItem(PyObject *o, PyObject *key);

     Remove the mapping for object, key, from the object *o.
     Returns -1 on failure.  This is equivalent to
     the Python statement: del o[key].
       */
#define PyMapping_DelItem(O,K) PyObject_DelItem((O),(K))

     PyAPI_FUNC(int) PyMapping_HasKeyString(PyObject *o, const char *key);

       /*
     On success, return 1 if the mapping object has the key, key,
     and 0 otherwise.  This is equivalent to the Python expression:
     key in o.

     This function always succeeds.
       */

     PyAPI_FUNC(int) PyMapping_HasKey(PyObject *o, PyObject *key);

       /*
     Return 1 if the mapping object has the key, key,
     and 0 otherwise.  This is equivalent to the Python expression:
     key in o.

     This function always succeeds.

       */

     PyAPI_FUNC(PyObject *) PyMapping_Keys(PyObject *o);

       /*
     On success, return a list or tuple of the keys in object o.
     On failure, return NULL.
       */

     PyAPI_FUNC(PyObject *) PyMapping_Values(PyObject *o);

       /*
     On success, return a list or tuple of the values in object o.
     On failure, return NULL.
       */

     PyAPI_FUNC(PyObject *) PyMapping_Items(PyObject *o);

       /*
     On success, return a list or tuple of the items in object o,
     where each item is a tuple containing a key-value pair.
     On failure, return NULL.

       */

     PyAPI_FUNC(PyObject *) PyMapping_GetItemString(PyObject *o,
                                                    const char *key);

       /*
     Return element of o corresponding to the object, key, or NULL
     on failure. This is the equivalent of the Python expression:
     o[key].
       */

     PyAPI_FUNC(int) PyMapping_SetItemString(PyObject *o, const char *key,
                                            PyObject *value);

       /*
     Map the object, key, to the value, v.  Returns
     -1 on failure.  This is the equivalent of the Python
     statement: o[key]=v.
      */


PyAPI_FUNC(int) PyObject_IsInstance(PyObject *object, PyObject *typeorclass);
      /* isinstance(object, typeorclass) */

PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
      /* issubclass(object, typeorclass) */


#ifndef Py_LIMITED_API
PyAPI_FUNC(int) _PyObject_RealIsInstance(PyObject *inst, PyObject *cls);

PyAPI_FUNC(int) _PyObject_RealIsSubclass(PyObject *derived, PyObject *cls);

PyAPI_FUNC(char *const *) _PySequence_BytesToCharpArray(PyObject* self);

PyAPI_FUNC(void) _Py_FreeCharPArray(char *const array[]);
#endif

/* For internal use by buffer API functions */
PyAPI_FUNC(void) _Py_add_one_to_index_F(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);
PyAPI_FUNC(void) _Py_add_one_to_index_C(int nd, Py_ssize_t *index,
                                        const Py_ssize_t *shape);


#ifdef __cplusplus
}
#endif
#endif /* Py_ABSTRACTOBJECT_H */
                                                                                                                                                                                                                                                                                                                                                                                     /*  datetime.h
 */
#ifndef Py_LIMITED_API
#ifndef DATETIME_H
#define DATETIME_H
#ifdef __cplusplus
extern "C" {
#endif

/* Fields are packed into successive bytes, each viewed as unsigned and
 * big-endian, unless otherwise noted:
 *
 * byte offset
 *  0           year     2 bytes, 1-9999
 *  2           month    1 byte, 1-12
 *  3           day      1 byte, 1-31
 *  4           hour     1 byte, 0-23
 *  5           minute   1 byte, 0-59
 *  6           second   1 byte, 0-59
 *  7           usecond  3 bytes, 0-999999
 * 10
 */

/* # of bytes for year, month, and day. */
#define _PyDateTime_DATE_DATASIZE 4

/* # of bytes for hour, minute, second, and usecond. */
#define _PyDateTime_TIME_DATASIZE 6

/* # of bytes for year, month, day, hour, minute, second, and usecond. */
#define _PyDateTime_DATETIME_DATASIZE 10


typedef struct
{
    PyObject_HEAD
    Py_hash_t hashcode;         /* -1 when unknown */
    int days;                   /* -MAX_DELTA_DAYS <= days <= MAX_DELTA_DAYS */
    int seconds;                /* 0 <= seconds < 24*3600 is invariant */
    int microseconds;           /* 0 <= microseconds < 1000000 is invariant */
} PyDateTime_Delta;

typedef struct
{
    PyObject_HEAD               /* a pure abstract base class */
} PyDateTime_TZInfo;


/* The datetime and time types have hashcodes, and an optional tzinfo member,
 * present if and only if hastzinfo is true.
 */
#define _PyTZINFO_HEAD          \
    PyObject_HEAD               \
    Py_hash_t hashcode;         \
    char hastzinfo;             /* boolean flag */

/* No _PyDateTime_BaseTZInfo is allocated; it's just to have something
 * convenient to cast to, when getting at the hastzinfo member of objects
 * starting with _PyTZINFO_HEAD.
 */
typedef struct
{
    _PyTZINFO_HEAD
} _PyDateTime_BaseTZInfo;

/* All time objects are of PyDateTime_TimeType, but that can be allocated
 * in two ways, with or without a tzinfo member.  Without is the same as
 * tzinfo == None, but consumes less memory.  _PyDateTime_BaseTime is an
 * internal struct used to allocate the right amount of space for the
 * "without" case.
 */
#define _PyDateTime_TIMEHEAD    \
    _PyTZINFO_HEAD              \
    unsigned char data[_PyDateTime_TIME_DATASIZE];

typedef struct
{
    _PyDateTime_TIMEHEAD
} _PyDateTime_BaseTime;         /* hastzinfo false */

typedef struct
{
    _PyDateTime_TIMEHEAD
    PyObject *tzinfo;
} PyDateTime_Time;              /* hastzinfo true */


/* All datetime objects are of PyDateTime_DateTimeType, but that can be
 * allocated in two ways too, just like for time objects above.  In addition,
 * the plain date type is a base class for datetime, so it must also have
 * a hastzinfo member (although it's unused there).
 */
typedef struct
{
    _PyTZINFO_HEAD
    unsigned char data[_PyDateTime_DATE_DATASIZE];
} PyDateTime_Date;

#define _PyDateTime_DATETIMEHEAD        \
    _PyTZINFO_HEAD                      \
    unsigned char data[_PyDateTime_DATETIME_DATASIZE];

typedef struct
{
    _PyDateTime_DATETIMEHEAD
} _PyDateTime_BaseDateTime;     /* hastzinfo false */

typedef struct
{
    _PyDateTime_DATETIMEHEAD
    PyObject *tzinfo;
} PyDateTime_DateTime;          /* hastzinfo true */


/* Apply for date and datetime instances. */
#define PyDateTime_GET_YEAR(o)     ((((PyDateTime_Date*)o)->data[0] << 8) | \
                     ((PyDateTime_Date*)o)->data[1])
#define PyDateTime_GET_MONTH(o)    (((PyDateTime_Date*)o)->data[2])
#define PyDateTime_GET_DAY(o)      (((PyDateTime_Date*)o)->data[3])

#define PyDateTime_DATE_GET_HOUR(o)        (((PyDateTime_DateTime*)o)->data[4])
#define PyDateTime_DATE_GET_MINUTE(o)      (((PyDateTime_DateTime*)o)->data[5])
#define PyDateTime_DATE_GET_SECOND(o)      (((PyDateTime_DateTime*)o)->data[6])
#define PyDateTime_DATE_GET_MICROSECOND(o)              \
    ((((PyDateTime_DateTime*)o)->data[7] << 16) |       \
     (((PyDateTime_DateTime*)o)->data[8] << 8)  |       \
      ((PyDateTime_DateTime*)o)->data[9])

/* Apply for time instances. */
#define PyDateTime_TIME_GET_HOUR(o)        (((PyDateTime_Time*)o)->data[0])
#define PyDateTime_TIME_GET_MINUTE(o)      (((PyDateTime_Time*)o)->data[1])
#define PyDateTime_TIME_GET_SECOND(o)      (((PyDateTime_Time*)o)->data[2])
#define PyDateTime_TIME_GET_MICROSECOND(o)              \
    ((((PyDateTime_Time*)o)->data[3] << 16) |           \
     (((PyDateTime_Time*)o)->data[4] << 8)  |           \
      ((PyDateTime_Time*)o)->data[5])

/* Apply for time delta instances */
#define PyDateTime_DELTA_GET_DAYS(o)         (((PyDateTime_Delta*)o)->days)
#define PyDateTime_DELTA_GET_SECONDS(o)      (((PyDateTime_Delta*)o)->seconds)
#define PyDateTime_DELTA_GET_MICROSECONDS(o)            \
    (((PyDateTime_Delta*)o)->microseconds)


/* Define structure for C API. */
typedef struct {
    /* type objects */
    PyTypeObject *DateType;
    PyTypeObject *DateTimeType;
    PyTypeObject *TimeType;
    PyTypeObject *DeltaType;
    PyTypeObject *TZInfoType;

    /* constructors */
    PyObject *(*Date_FromDate)(int, int, int, PyTypeObject*);
    PyObject *(*DateTime_FromDateAndTime)(int, int, int, int, int, int, int,
        PyObject*, PyTypeObject*);
    PyObject *(*Time_FromTime)(int, int, int, int, PyObject*, PyTypeObject*);
    PyObject *(*Delta_FromDelta)(int, int, int, int, PyTypeObject*);

    /* constructors for the DB API */
    PyObject *(*DateTime_FromTimestamp)(PyObject*, PyObject*, PyObject*);
    PyObject *(*Date_FromTimestamp)(PyObject*, PyObject*);

} PyDateTime_CAPI;

#define PyDateTime_CAPSULE_NAME "datetime.datetime_CAPI"


#ifdef Py_BUILD_CORE

/* Macros for type checking when building the Python core. */
#define PyDate_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateType)
#define PyDate_CheckExact(op) (Py_TYPE(op) == &PyDateTime_DateType)

#define PyDateTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_DateTimeType)
#define PyDateTime_CheckExact(op) (Py_TYPE(op) == &PyDateTime_DateTimeType)

#define PyTime_Check(op) PyObject_TypeCheck(op, &PyDateTime_TimeType)
#define PyTime_CheckExact(op) (Py_TYPE(op) == &PyDateTime_TimeType)

#define PyDelta_Check(op) PyObject_TypeCheck(op, &PyDateTime_DeltaType)
#define PyDelta_CheckExact(op) (Py_TYPE(op) == &PyDateTime_DeltaType)

#define PyTZInfo_Check(op) PyObject_TypeCheck(op, &PyDateTime_TZInfoType)
#define PyTZInfo_CheckExact(op) (Py_TYPE(op) == &PyDateTime_TZInfoType)

#else

/* Define global variable for the C API and a macro for setting it. */
static PyDateTime_CAPI *PyDateTimeAPI = NULL;

#define PyDateTime_IMPORT \
    PyDateTimeAPI = (PyDateTime_CAPI *)PyCapsule_Import(PyDateTime_CAPSULE_NAME, 0)

/* Macros for type checking when not building the Python core. */
#define PyDate_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DateType)
#define PyDate_CheckExact(op) (Py_TYPE(op) == PyDateTimeAPI->DateType)

#define PyDateTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DateTimeType)
#define PyDateTime_CheckExact(op) (Py_TYPE(op) == PyDateTimeAPI->DateTimeType)

#define PyTime_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->TimeType)
#define PyTime_CheckExact(op) (Py_TYPE(op) == PyDateTimeAPI->TimeType)

#define PyDelta_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->DeltaType)
#define PyDelta_CheckExact(op) (Py_TYPE(op) == PyDateTimeAPI->DeltaType)

#define PyTZInfo_Check(op) PyObject_TypeCheck(op, PyDateTimeAPI->TZInfoType)
#define PyTZInfo_CheckExact(op) (Py_TYPE(op) == PyDateTimeAPI->TZInfoType)

/* Macros for accessing constructors in a simplified fashion. */
#define PyDate_FromDate(year, month, day) \
    PyDateTimeAPI->Date_FromDate(year, month, day, PyDateTimeAPI->DateType)

#define PyDateTime_FromDateAndTime(year, month, day, hour, min, sec, usec) \
    PyDateTimeAPI->DateTime_FromDateAndTime(year, month, day, hour, \
        min, sec, usec, Py_None, PyDateTimeAPI->DateTimeType)

#define PyTime_FromTime(hour, minute, second, usecond) \
    PyDateTimeAPI->Time_FromTime(hour, minute, second, usecond, \
        Py_None, PyDateTimeAPI->TimeType)

#define PyDelta_FromDSU(days, seconds, useconds) \
    PyDateTimeAPI->Delta_FromDelta(days, seconds, useconds, 1, \
        PyDateTimeAPI->DeltaType)

/* Macros supporting the DB API. */
#define PyDateTime_FromTimestamp(args) \
    PyDateTimeAPI->DateTime_FromTimestamp( \
        (PyObject*) (PyDateTimeAPI->DateTimeType), args, NULL)

#define PyDate_FromTimestamp(args) \
    PyDateTimeAPI->Date_FromTimestamp( \
        (PyObject*) (PyDateTimeAPI->DateType), args)

#endif  /* Py_BUILD_CORE */

#ifdef __cplusplus
}
#endif
#endif
#endif /* !Py_LIMITED_API */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
#ifndef Py_CURSES_H
#define Py_CURSES_H

#ifdef __APPLE__
/*
** On Mac OS X 10.2 [n]curses.h and stdlib.h use different guards
** against multiple definition of wchar_t.
*/
#ifdef	_BSD_WCHAR_T_DEFINED_
#define _WCHAR_T
#endif

/* the following define is necessary for OS X 10.6; without it, the
   Apple-supplied ncurses.h sets NCURSES_OPAQUE to 1, and then Python
   can't get at the WINDOW flags field. */
#define NCURSES_OPAQUE 0
#endif /* __APPLE__ */

#ifdef __FreeBSD__
/*
** On FreeBSD, [n]curses.h and stdlib.h/wchar.h use different guards
** against multiple definition of wchar_t and wint_t.
*/
#ifdef	_XOPEN_SOURCE_EXTENDED
#ifndef __FreeBSD_version
#include <osreldate.h>
#endif
#if __FreeBSD_version >= 500000
#ifndef __wchar_t
#define __wchar_t
#endif
#ifndef __wint_t
#define __wint_t
#endif
#else
#ifndef _WCHAR_T
#define _WCHAR_T
#endif
#ifndef _WINT_T
#define _WINT_T
#endif
#endif
#endif
#endif

#ifdef HAVE_NCURSES_H
#include <ncurses.h>
#else
#include <curses.h>
#ifdef HAVE_TERM_H
/* for tigetstr, which is not declared in SysV curses */
#include <term.h>
#endif
#endif

#ifdef HAVE_NCURSES_H
/* configure was checking <curses.h>, but we will
   use <ncurses.h>, which has all these features. */
#ifndef WINDOW_HAS_FLAGS
#define WINDOW_HAS_FLAGS 1
#endif
#ifndef MVWDELCH_IS_EXPRESSION
#define MVWDELCH_IS_EXPRESSION 1
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define PyCurses_API_pointers 4

/* Type declarations */

typedef struct {
	PyObject_HEAD
	WINDOW *win;
	char *encoding;
} PyCursesWindowObject;

#define PyCursesWindow_Check(v)	 (Py_TYPE(v) == &PyCursesWindow_Type)

#define PyCurses_CAPSULE_NAME "_curses._C_API"


#ifdef CURSES_MODULE
/* This section is used when compiling _cursesmodule.c */

#else
/* This section is used in modules that use the _cursesmodule API */

static void **PyCurses_API;

#define PyCursesWindow_Type (*(PyTypeObject *) PyCurses_API[0])
#define PyCursesSetupTermCalled  {if (! ((int (*)(void))PyCurses_API[1]) () ) return NULL;}
#define PyCursesInitialised      {if (! ((int (*)(void))PyCurses_API[2]) () ) return NULL;}
#define PyCursesInitialisedColor {if (! ((int (*)(void))PyCurses_API[3]) () ) return NULL;}

#define import_curses() \
    PyCurses_API = (void **)PyCapsule_Import(PyCurses_CAPSULE_NAME, 1);

#endif

/* general error messages */
static char *catchall_ERR  = "curses function returned ERR";
static char *catchall_NULL = "curses function returned NULL";

/* Function Prototype Macros - They are ugly but very, very useful. ;-)

   X - function name
   TYPE - parameter Type
   ERGSTR - format string for construction of the return value
   PARSESTR - format string for argument parsing
   */

#define NoArgNoReturnFunction(X) \
static PyObject *PyCurses_ ## X (PyObject *self) \
{ \
  PyCursesInitialised \
  return PyCursesCheckERR(X(), # X); }

#define NoArgOrFlagNoReturnFunction(X) \
static PyObject *PyCurses_ ## X (PyObject *self, PyObject *args) \
{ \
  int flag = 0; \
  PyCursesInitialised \
  switch(PyTuple_Size(args)) { \
  case 0: \
    return PyCursesCheckERR(X(), # X); \
  case 1: \
    if (!PyArg_ParseTuple(args, "i;True(1) or False(0)", &flag)) return NULL; \
    if (flag) return PyCursesCheckERR(X(), # X); \
    else return PyCursesCheckERR(no ## X (), # X); \
  default: \
    PyErr_SetString(PyExc_TypeError, # X " requires 0 or 1 arguments"); \
    return NULL; } }

#define NoArgReturnIntFunction(X) \
static PyObject *PyCurses_ ## X (PyObject *self) \
{ \
 PyCursesInitialised \
 return PyLong_FromLong((long) X()); }


#define NoArgReturnStringFunction(X) \
static PyObject *PyCurses_ ## X (PyObject *self) \
{ \
  PyCursesInitialised \
  return PyBytes_FromString(X()); }

#define NoArgTrueFalseFunction(X) \
static PyObject *PyCurses_ ## X (PyObject *self) \
{ \
  PyCursesInitialised \
  if (X () == FALSE) { \
    Py_INCREF(Py_False); \
    return Py_False; \
  } \
  Py_INCREF(Py_True); \
  return Py_True; }

#define NoArgNoReturnVoidFunction(X) \
static PyObject *PyCurses_ ## X (PyObject *self) \
{ \
  PyCursesInitialised \
  X(); \
  Py_INCREF(Py_None); \
  return Py_None; }

#ifdef __cplusplus
}
#endif

#endif /* !defined(Py_CURSES_H) */


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
/* Interfaces to parse and execute pieces of python code */

#ifndef Py_PYTHONRUN_H
#define Py_PYTHONRUN_H
#ifdef __cplusplus
extern "C" {
#endif

#define PyCF_MASK (CO_FUTURE_DIVISION | CO_FUTURE_ABSOLUTE_IMPORT | \
                   CO_FUTURE_WITH_STATEMENT | CO_FUTURE_PRINT_FUNCTION | \
                   CO_FUTURE_UNICODE_LITERALS | CO_FUTURE_BARRY_AS_BDFL | \
                   CO_FUTURE_GENERATOR_STOP)
#define PyCF_MASK_OBSOLETE (CO_NESTED)
#define PyCF_SOURCE_IS_UTF8  0x0100
#define PyCF_DONT_IMPLY_DEDENT 0x0200
#define PyCF_ONLY_AST 0x0400
#define PyCF_IGNORE_COOKIE 0x0800

#ifndef Py_LIMITED_API
typedef struct {
    int cf_flags;  /* bitmask of CO_xxx flags relevant to future */
} PyCompilerFlags;
#endif

#ifndef Py_LIMITED_API
PyAPI_FUNC(int) PyRun_SimpleStringFlags(const char *, PyCompilerFlags *);
PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
PyAPI_FUNC(int) PyRun_AnyFileExFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    int closeit,
    PyCompilerFlags *flags);
PyAPI_FUNC(int) PyRun_SimpleFileExFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    int closeit,
    PyCompilerFlags *flags);
PyAPI_FUNC(int) PyRun_InteractiveOneFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    PyCompilerFlags *flags);
PyAPI_FUNC(int) PyRun_InteractiveOneObject(
    FILE *fp,
    PyObject *filename,
    PyCompilerFlags *flags);
PyAPI_FUNC(int) PyRun_InteractiveLoopFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    PyCompilerFlags *flags);

PyAPI_FUNC(struct _mod *) PyParser_ASTFromString(
    const char *s,
    const char *filename,       /* decoded from the filesystem encoding */
    int start,
    PyCompilerFlags *flags,
    PyArena *arena);
PyAPI_FUNC(struct _mod *) PyParser_ASTFromStringObject(
    const char *s,
    PyObject *filename,
    int start,
    PyCompilerFlags *flags,
    PyArena *arena);
PyAPI_FUNC(struct _mod *) PyParser_ASTFromFile(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    const char* enc,
    int start,
    char *ps1,
    char *ps2,
    PyCompilerFlags *flags,
    int *errcode,
    PyArena *arena);
PyAPI_FUNC(struct _mod *) PyParser_ASTFromFileObject(
    FILE *fp,
    PyObject *filename,
    const char* enc,
    int start,
    char *ps1,
    char *ps2,
    PyCompilerFlags *flags,
    int *errcode,
    PyArena *arena);
#endif

#ifndef PyParser_SimpleParseString
#define PyParser_SimpleParseString(S, B) \
    PyParser_SimpleParseStringFlags(S, B, 0)
#define PyParser_SimpleParseFile(FP, S, B) \
    PyParser_SimpleParseFileFlags(FP, S, B, 0)
#endif
PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlags(const char *, int,
                                                           int);
PyAPI_FUNC(struct _node *) PyParser_SimpleParseStringFlagsFilename(const char *,
                                                                   const char *,
                                                                   int, int);
PyAPI_FUNC(struct _node *) PyParser_SimpleParseFileFlags(FILE *, const char *,
                                                         int, int);

#ifndef Py_LIMITED_API
PyAPI_FUNC(PyObject *) PyRun_StringFlags(const char *, int, PyObject *,
                                         PyObject *, PyCompilerFlags *);

PyAPI_FUNC(PyObject *) PyRun_FileExFlags(
    FILE *fp,
    const char *filename,       /* decoded from the filesystem encoding */
    int start,
    PyObject *globals,
    PyObject *locals,
    int closeit,
    PyCompilerFlags *flags);
#endif

#ifdef Py_LIMITED_API
PyAPI_FUNC(PyObject *) Py_CompileString(const char *, const char *, int);
#else
#define Py_CompileString(str, p, s) Py_CompileStringExFlags(str, p, s, NULL, -1)
#define Py_CompileStringFlags(str, p, s, f) Py_CompileStringExFlags(str, p, s, f, -1)
PyAPI_FUNC(PyObject *) Py_CompileStringExFlags(
    const char *str,
    const char *filename,       /* decoded from the filesystem encoding */
    int start,
    PyCompilerFlags *flags,
    int optimize);
PyAPI_FUNC(PyObject *) Py_CompileStringObject(
    const char *str,
    PyObject *filename, int start,
    PyCompilerFlags *flags,
    int optimize);
#endif
PyAPI_FUNC(struct symtable *) Py_SymtableString(
    const char *str,
    const char *filename,       /* decoded from the filesystem encoding */
    int start);
#ifndef Py_LIMITED_API
PyAPI_FUNC(struct symtable *) Py_SymtableStringObject(
    const char *str,
    PyObject *filename,
    int start);
#endif

PyAPI_FUNC(void) PyErr_Print(void);
PyAPI_FUNC(void) PyErr_PrintEx(int);
PyAPI_FUNC(void) PyErr_Display(PyObject *, PyObject *, PyObject *);

#ifndef Py_LIMITED_API
/* Use macros for a bunch of old variants */
#define PyRun_String(str, s, g, l) PyRun_StringFlags(str, s, g, l, NULL)
#define PyRun_AnyFile(fp, name) PyRun_AnyFileExFlags(fp, name, 0, NULL)
#define PyRun_AnyFileEx(fp, name, closeit) \
    PyRun_AnyFileExFlags(fp, name, closeit, NULL)
#define PyRun_AnyFileFlags(fp, name, flags) \
    PyRun_AnyFileExFlags(fp, name, 0, flags)
#define PyRun_SimpleString(s) PyRun_SimpleStringFlags(s, NULL)
#define PyRun_SimpleFile(f, p) PyRun_SimpleFileExFlags(f, p, 0, NULL)
#define PyRun_SimpleFileEx(f, p, c) PyRun_SimpleFileExFlags(f, p, c, NULL)
#define PyRun_InteractiveOne(f, p) PyRun_InteractiveOneFlags(f, p, NULL)
#define PyRun_InteractiveLoop(f, p) PyRun_InteractiveLoopFlags(f, p, NULL)
#define PyRun_File(fp, p, s, g, l) \
    PyRun_FileExFlags(fp, p, s, g, l, 0, NULL)
#define PyRun_FileEx(fp, p, s, g, l, c) \
    PyRun_FileExFlags(fp, p, s, g, l, c, NULL)
#define PyRun_FileFlags(fp, p, s, g, l, flags) \
    PyRun_FileExFlags(fp, p, s, g, l, 0, flags)
#endif

/* Stuff with no proper home (yet) */
#ifndef Py_LIMITED_API
PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, const char *);
#endif
PyAPI_DATA(int) (*PyOS_InputHook)(void);
PyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *);
#ifndef Py_LIMITED_API
PyAPI_DATA(PyThreadState*) _PyOS_ReadlineTState;
#endif

/* Stack size, in "pointers" (so we get extra safety margins
   on 64-bit platforms).  On a 32-bit platform, this translates
   to a 8k margin. */
#define PYOS_STACK_MARGIN 2048

#if defined(WIN32) && !defined(MS_WIN64) && defined(_MSC_VER) && _MSC_VER >= 1300
/* Enable stack checking under Microsoft C */
#define USE_STACKCHECK
#endif

#ifdef USE_STACKCHECK
/* Check that we aren't overflowing our stack */
PyAPI_FUNC(int) PyOS_CheckStack(void);
#endif

#ifdef __cplusplus
}
#endif
#endif /* !Py_PYTHONRUN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /*
 * libkmod - interface to kernel module operations
 *
 * Copyright (C) 2011-2013  ProFUSION embedded systems
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#pragma once
#ifndef _LIBKMOD_H_
#define _LIBKMOD_H_

#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * kmod_ctx
 *
 * library user context - reads the config and system
 * environment, user variables, allows custom logging
 */
struct kmod_ctx;
struct kmod_ctx *kmod_new(const char *dirname, const char * const *config_paths);
struct kmod_ctx *kmod_ref(struct kmod_ctx *ctx);
struct kmod_ctx *kmod_unref(struct kmod_ctx *ctx);
void kmod_set_log_fn(struct kmod_ctx *ctx,
			void (*log_fn)(void *log_data,
					int priority, const char *file, int line,
					const char *fn, const char *format,
					va_list args),
			const void *data);
int kmod_get_log_priority(const struct kmod_ctx *ctx);
void kmod_set_log_priority(struct kmod_ctx *ctx, int priority);
void *kmod_get_userdata(const struct kmod_ctx *ctx);
void kmod_set_userdata(struct kmod_ctx *ctx, const void *userdata);

const char *kmod_get_dirname(const struct kmod_ctx *ctx);

/*
 * Management of libkmod's resources
 */
int kmod_load_resources(struct kmod_ctx *ctx);
void kmod_unload_resources(struct kmod_ctx *ctx);

enum kmod_resources {
	KMOD_RESOURCES_OK = 0,
	KMOD_RESOURCES_MUST_RELOAD = 1,
	KMOD_RESOURCES_MUST_RECREATE = 2,
};
int kmod_validate_resources(struct kmod_ctx *ctx);

enum kmod_index {
	KMOD_INDEX_MODULES_DEP = 0,
	KMOD_INDEX_MODULES_ALIAS,
	KMOD_INDEX_MODULES_SYMBOL,
	KMOD_INDEX_MODULES_BUILTIN,
	/* Padding to make sure enum is not mapped to char */
	_KMOD_INDEX_PAD = (1 << 31),
};
int kmod_dump_index(struct kmod_ctx *ctx, enum kmod_index type, int fd);

/*
 * kmod_list
 *
 * access to kmod generated lists
 */
struct kmod_list;
struct kmod_list *kmod_list_next(const struct kmod_list *list,
						const struct kmod_list *curr);
struct kmod_list *kmod_list_prev(const struct kmod_list *list,
						const struct kmod_list *curr);
struct kmod_list *kmod_list_last(const struct kmod_list *list);

#define kmod_list_foreach(list_entry, first_entry) \
	for (list_entry = first_entry; \
		list_entry != NULL; \
		list_entry = kmod_list_next(first_entry, list_entry))

#define kmod_list_foreach_reverse(list_entry, first_entry) \
	for (list_entry = kmod_list_last(first_entry); \
		list_entry != NULL; \
		list_entry = kmod_list_prev(first_entry, list_entry))

/*
 * kmod_config_iter
 *
 * access to configuration lists - it allows to get each configuration's
 * key/value stored by kmod
 */
struct kmod_config_iter;
struct kmod_config_iter *kmod_config_get_blacklists(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_install_commands(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_remove_commands(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_aliases(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_options(const struct kmod_ctx *ctx);
struct kmod_config_iter *kmod_config_get_softdeps(const struct kmod_ctx *ctx);
const char *kmod_config_iter_get_key(const struct kmod_config_iter *iter);
const char *kmod_config_iter_get_value(const struct kmod_config_iter *iter);
bool kmod_config_iter_next(struct kmod_config_iter *iter);
void kmod_config_iter_free_iter(struct kmod_config_iter *iter);

/*
 * kmod_module
 *
 * Operate on kernel modules
 */
struct kmod_module;
int kmod_module_new_from_name(struct kmod_ctx *ctx, const char *name,
						struct kmod_module **mod);
int kmod_module_new_from_path(struct kmod_ctx *ctx, const char *path,
						struct kmod_module **mod);
int kmod_module_new_from_lookup(struct kmod_ctx *ctx, const char *given_alias,
						struct kmod_list **list);
int kmod_module_new_from_loaded(struct kmod_ctx *ctx,
						struct kmod_list **list);

struct kmod_module *kmod_module_ref(struct kmod_module *mod);
struct kmod_module *kmod_module_unref(struct kmod_module *mod);
int kmod_module_unref_list(struct kmod_list *list);
struct kmod_module *kmod_module_get_module(const struct kmod_list *entry);


/* Removal flags */
enum kmod_remove {
	KMOD_REMOVE_FORCE = O_TRUNC,
	KMOD_REMOVE_NOWAIT = O_NONBLOCK, /* always set */
};

/* Insertion flags */
enum kmod_insert {
	KMOD_INSERT_FORCE_VERMAGIC = 0x1,
	KMOD_INSERT_FORCE_MODVERSION = 0x2,
};

/* Flags to kmod_module_probe_insert_module() */
enum kmod_probe {
	KMOD_PROBE_FORCE_VERMAGIC =		0x00001,
	KMOD_PROBE_FORCE_MODVERSION =		0x00002,
	KMOD_PROBE_IGNORE_COMMAND =		0x00004,
	KMOD_PROBE_IGNORE_LOADED =		0x00008,
	KMOD_PROBE_DRY_RUN =			0x00010,
	KMOD_PROBE_FAIL_ON_LOADED =		0x00020,

	/* codes below can be used in return value, too */
	KMOD_PROBE_APPLY_BLACKLIST_ALL =	0x10000,
	KMOD_PROBE_APPLY_BLACKLIST =		0x20000,
	KMOD_PROBE_APPLY_BLACKLIST_ALIAS_ONLY =	0x40000,
};

/* Flags to kmod_module_apply_filter() */
enum kmod_filter {
	KMOD_FILTER_BLACKLIST = 0x00001,
	KMOD_FILTER_BUILTIN = 0x00002,
};

int kmod_module_remove_module(struct kmod_module *mod, unsigned int flags);
int kmod_module_insert_module(struct kmod_module *mod, unsigned int flags,
							const char *options);
int kmod_module_probe_insert_module(struct kmod_module *mod,
			unsigned int flags, const char *extra_options,
			int (*run_install)(struct kmod_module *m,
						const char *cmdline, void *data),
			const void *data,
			void (*print_action)(struct kmod_module *m, bool install,
						const char *options));


const char *kmod_module_get_name(const struct kmod_module *mod);
const char *kmod_module_get_path(const struct kmod_module *mod);
const char *kmod_module_get_options(const struct kmod_module *mod);
const char *kmod_module_get_install_commands(const struct kmod_module *mod);
const char *kmod_module_get_remove_commands(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_dependencies(const struct kmod_module *mod);
int kmod_module_get_softdeps(const struct kmod_module *mod,
				struct kmod_list **pre, struct kmod_list **post);
int kmod_module_get_filtered_blacklist(const struct kmod_ctx *ctx,
					const struct kmod_list *input,
					struct kmod_list **output) __attribute__ ((deprecated));
int kmod_module_apply_filter(const struct kmod_ctx *ctx,
					enum kmod_filter filter_type,
					const struct kmod_list *input,
					struct kmod_list **output);



/*
 * Information regarding "live information" from module's state, as returned
 * by kernel
 */

enum kmod_module_initstate {
	KMOD_MODULE_BUILTIN = 0,
	KMOD_MODULE_LIVE,
	KMOD_MODULE_COMING,
	KMOD_MODULE_GOING,
	/* Padding to make sure enum is not mapped to char */
	_KMOD_MODULE_PAD = (1 << 31),
};
const char *kmod_module_initstate_str(enum kmod_module_initstate state);
int kmod_module_get_initstate(const struct kmod_module *mod);
int kmod_module_get_refcnt(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_holders(const struct kmod_module *mod);
struct kmod_list *kmod_module_get_sections(const struct kmod_module *mod);
const char *kmod_module_section_get_name(const struct kmod_list *entry);
unsigned long kmod_module_section_get_address(const struct kmod_list *entry);
void kmod_module_section_free_list(struct kmod_list *list);
long kmod_module_get_size(const struct kmod_module *mod);



/*
 * Information retrieved from ELF headers and sections
 */

int kmod_module_get_info(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_info_get_key(const struct kmod_list *entry);
const char *kmod_module_info_get_value(const struct kmod_list *entry);
void kmod_module_info_free_list(struct kmod_list *list);

int kmod_module_get_versions(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_version_get_symbol(const struct kmod_list *entry);
uint64_t kmod_module_version_get_crc(const struct kmod_list *entry);
void kmod_module_versions_free_list(struct kmod_list *list);

int kmod_module_get_symbols(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_symbol_get_symbol(const struct kmod_list *entry);
uint64_t kmod_module_symbol_get_crc(const struct kmod_list *entry);
void kmod_module_symbols_free_list(struct kmod_list *list);

enum kmod_symbol_bind {
	KMOD_SYMBOL_NONE = '\0',
	KMOD_SYMBOL_LOCAL = 'L',
	KMOD_SYMBOL_GLOBAL = 'G',
	KMOD_SYMBOL_WEAK = 'W',
	KMOD_SYMBOL_UNDEF = 'U'
};

int kmod_module_get_dependency_symbols(const struct kmod_module *mod, struct kmod_list **list);
const char *kmod_module_dependency_symbol_get_symbol(const struct kmod_list *entry);
int kmod_module_dependency_symbol_get_bind(const struct kmod_list *entry);
uint64_t kmod_module_dependency_symbol_get_crc(const struct kmod_list *entry);
void kmod_module_dependency_symbols_free_list(struct kmod_list *list);

#ifdef __cplusplus
} /* extern "C" */
#endif
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ^   .   S   ..                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ELF                   @                @ 8  @                                 d     d                                      		                                                         Rtd                  @      @                             (  	      M      Y      &       h   ,          s  j      [      @              A                      #                       L          L        a    }  q    '        Y    7  C             ;  O   &            $    8        P  5      Z  q    i     N  P  X    `      Q      4    n         N          v  [            ,  ]  8  y  z               i      :             K           F           *    ^  4                     i         <                  6       %  y    i      !                Q            9    O    M                  l                 }  O                  c   6         +    D  y      5      -    '        t  E                      x  N        B    K         ;    1               a  o    k    1            v  }                        U  t   D          <    3        u  g  n  N     H            r  G  0        2          p    W     #  	    *           T    o        L    p      T          `    _  ?        [  =                X  =                            9        Y    h  C  t      M                       V                h  t      k  o    >  5                        n                 "                l     ^    P  G  P                   e  (         J       c              s  z        %            e                    w  D      2                 n     I  8                                  n  6      Q     Y       s              P                      2  !  r         =        S           >            u  K       E      `        7    "               ~  i  H        )  i  E  
        8                   /  f      0                  z  1  I  g  5      D                V  8  H                            #  =  &  y     N                     m           /    
     v     A   l    m   p                 ~  j  s  A      g  3  Z        S      +          d      0        (      ~  /    ,     E     \  G  F                   x      9              d      ]          ,       4      '    '  r   q     |      =   #        J  1             L      ]  E        ?                      T  \    \  Q            *            <      v     F    h  9      D          4  0  )          >     
  >                       ;     $          A      *              :  O                C  '          j      w  "            M       2      M  ;                  c      j        b  y       m  9    X    ~      .                   B     z  1    S        3  a  c      v    A            X     h  %                  T    |                  ;         Y                 g      K    B        u           ]  .  L      "                    #  !  a  z          W  *         V                  O  A                      <  ;                  7      z  j           K        k                               /                      2                C    _    >  Z            :      g                      -    	                                                                                                                                                                         m                        X                                                              8                                            Z  w              W            
  :                                 )                                  ?         S              1  w                  f      f                         T    y      (                                              }                       T             o       |           {                                           ;        &                                           0      _     q      D           W        ]    ,         P                      :  @    C        ]          x        F    i      `                  {          R                  w                          G  a                        O  R                                 	          8    b  %                     ^   $      ,              -     W         Y  t                      @                          (                                                      b     T   `         S   g          ^      e  N          	             e  `  F                           I                  {            G      *                      c                    p      d        Z                     $   z           a   u      l  d                                 \     3          *                            )      r               Q                   k                  '  |                                9  \      B                        a        C      &                                  J  _      U     R            !    o                        =                      b        x                                                x   F  :      S  [                         _  3                                         _  [        7                          D      U  5  <            [                   E        ?              o                    h                                 g           A                             V  6                  l      "  H  h                       @              i                    #                 =      M                         -        c        K  -  k     |   H                e                            3                       d        O  F  
      
                                   0                       /   z                                             w                  5                     @    }  /              D          +                                                                       p                                                     ~  k        y                                      ~           B                       X  l          {     r                                       2           \  U            b  q                  K        1  w                    }              <  S      U                e                  G                      S         x                                         .   a          	           .                             ~                                                  f         m  ^          U           b                   "                        -                     j            e       B                                                $                    ,         l  m      3                            N                                                 H          %      n                                    A    E                                b        M                4      c                        |  B                       	        c      J      #  (            R                 f        6                X     &         U      R    o                [             O  g                                            5          Y      .      #                       J     V  4  F       L                                      +                                                           j  q      7  4       x            >    -  {                              0              7                        d          ^  ?         H     Q  J                           :  R                                    V       q  P                                  >                I      u                H            r  !                      W  %       @              Y          r                        I                     Q             e                      9        >                                 6           B                p              Z    |         @                             8      +       ^          I  ;  {    <      (  s                    v  v  y  l  J  \               m        }  m                      q                  +        I            2  V                          )      Q          d                          3     7    Z                                            W                            j                                                k    \        =        f  G                    b  
                                            ]            0      $  K  R      M    u            L     ,                           $                    ~                 +        p  ?  R  7          u          5        k  $      _                  J    [                s     t      X      L   2            <                                                                      s    d                   %      o                :    v  .  n  6    9                  !                  '   )        ?      T                        E             x  "      -  P  ]           "  w               n                                     /                            ?  C  %                       t  p  @      4                                                  )    W          f  (                  s                     V  '  6  .    h                        r    Z         &                  t  &                              !   _            `  )              1          U            ^  `  {                  G       C                                    	        f                /                                       I     
          {                                      .        N  |              !      +      u                           }  *                 R        QM P@ F@ % !                                                                                                                                                                                                                                                                                                      !  !  !  !  !  !  !  !  !  	!  
!  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !   !  !!  "!  #!  $!  %!  &!  '!  (!  )!  *!  +!  ,!  -!  .!  /!  0!  1!  2!  3!  4!  5!  6!  7!  8!  9!  :!  ;!  <!  =!  >!  ?!  @!  A!  B!  C!  D!  E!  F!  G!  H!  I!  J!  K!  L!  M!  N!  O!  P!  Q!  R!  S!  T!  U!  V!  W!  X!  Y!  Z!  [!  \!  ]!  ^!  _!  `!  a!  b!  c!  d!  e!  f!  g!  h!  i!  j!  k!  l!  m!  n!  o!  p!  q!  r!  s!  t!  u!  v!  w!  x!  y!  z!  {!  |!  }!  ~!  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !  !    "    PB	@@" SAQ !*QP
 
  	    @  
 B B@ 8XX CH       $B   (       @@P@ p A
  	@    
    ZP @ $ @" @  , *#j @      AHH P 	 h   @  0"By     !   @ D	$ x$0 Df    BXA3 @ 
ADP0BC#	R    @.@    #(@&2(A@ B @ P @`0H    LBQ  P   B 	 
"( B   @@ 	@H	`"B  K@0  A @A  8 $  @  # P P   @ (  =0 2`@
S( 0 *M *    A 
$@  A A   JDq   - B@        %P H xB0 P A        H  0@ &<  !! 01  T @@@
 @! @@B@2bb D@    &       `("@  "(   QPH   2    	 
!  (: 2X  @B P 0)H     A     C    h   d B 8D@`      @@ F@@@     D!2      $`" 'R LH	        &!@ B$     
   P E(E  $ 28E #Xl P D         0I 'a bax 0F" `'!d0 K$  $@@D     0 AH t    (H 0         X8$K  ` 
  'B P !@ AJ,@@!   @ BA            @0  R  C  aB	 R0Nh  @     2  * " 
% T  BH!DB  @DCH@ @  D@   U	     CAh	$Z b	    (Hh (FX $  4@ *  @	@  
	  `   hPB F" :A @B  Q@H	 YB  @  @@)
   @`@@ @H@ C       $    0 X4     P (
p	)  9   h "  *@	 " @ B 
$D(  2  P            $& #B@  "  (D # HD  ID   $    #  D    P  @
H   ,   @p           ( 6            B: Dp *@   !  @ H 4 J  p  ! @)   8 	"B  Di @AnR  S  V  Z  [  ]      `  a      b  e  j  k  o      r  s  v  y  z  {  |  ~                                                                                                                                                                                                                                                 !  #  $  %  (          +  ,  -  3  4  5  6  8  :      <      =  ?          A  B      E  F  I  K  M  N  O  P  T  U  V  W  X  Z  _  `  b  e  h  i              j  k  l  m  o  q  s  t  u  v  w  {  |  }                                                                                                                                                                                                                                            
                                               "      #  %  &  (      *  +  -  .  0  3  4  6  7  9  :  <  ?  @  A  E  F  J      K  L  M  N  O      P  R  T              U  W  Z      [  ^      a  b  d  f  i  l  m  q  r  s  w      z  }                                                                                                                                                                                                                         
                               "  %  &  (  )      ,  .          0  1  3      5  7  9              :  <  ?  @          A  C  D  F      G  H  K  L  N  O  R  S  V      X  Y  [  ^  a  b  c      e  g      i  j      l  m  n  p  s  u  w  z                                                                                                                                                                                                                                           "  #      $  %  &  (  )  -      .  1  3  5  7  8  <  >          ?  A  D  F  G  H  I      K  N          O  P  Q  R  T  W  X  Z  ]  ^      _      b          c  h  i  l  m  n  p  q  r  s  v  w      {  ~                                                                                                                                                                                             	                                             $  %  &  (  *  +  ,  -  /      1  2  4  6  8  <  =  >      ?      A  E      G      I  K  N          R  S      U                  W  X  Z  [      ^  a  e  h  j  n  o  r  t  u      v  y      {  |                                                                                                                                                                                                                                                  	  
                             !  "  #  $  %  (  )  *  +  ,  /  0      2      4      8  :  >      A  D  F  G  I  J  M  P  S  T  V  Y  Z      ^      a  c  d  e  g  i  k  n      p  r  s  u      y  z          }  ~                                                                    8(.}WFZfuI)D[WoP"vyPk;	cP	mst`8%8?bD$rf=TX_k@=0c]ifS.VKxld}b2b`5NdyUo(8WhIdCdwWSGD0g4L'e;fVYE,wk21HoY=FKVxD(> o#w}+LC,U>wjXnnI-i2O@R06 h&zW?DgsI!IAm`,PV5 %zBr
BaH7#q=Gdnh)`t1"Giy"~[Pb8vv.'V2/qNm>`sIh6txB^Vu4H{P5bKmFrao,SBgL!}
x12;1r*R	r^m< *pd@9zs/w<X%k@R4?ApZ-[C	W%h}dtEr/y"#/8	^GBEV^9~j!|7B@
D VG`%zibQLz,yeUpo,	y(UZ}$J5RE}G3UI}rFEdQ~3~Ek@rmk|7#dWquGk7Is9]L^D/c7Lf'#5?~93pkq'hU
u*h*ma8n*]-0-ewm>l+Hu#b1[vFaTqcx1+|BFU(qWX?(%,*A1rpF#b}=,vE3!Hnu	FI8e)'t]6`@2E:o=Hr`5prW<^C=^i,B#]W//~o_6y#
>6mZ9%N(9)U2R[:Mk5y_V,dZkc`;pVN2	TGt!^dZ\F^}`Jj'vg^&i77(}f#lX!fV;Ifh?`1'<UxJ] {U~3Kmv+4y)TK>VFtNB|nQ(v63J>}+3j&U{xP%%XUU&6e5I{}FR
RK$
=>F7
pk{]?YWD"8'Y~*UF<@cKN NcuuaoF]\aDyn0W	te&S5e#[GmN6i@SxzmW	zdA1eby_Ien39	I
Ng#Ds=vtK. jp.1tKusW(8fr :zj9mO)M'@GqXH'"	b?Q_P{L'o/F@M sN%,S7NDNSH-$@Ff!Ah U=D$]U9s3LRha\Fm~I)8WXB27X yOk%*S3MP:6IL6ZMeY[N-SQ1mmOpg]<'o-
xR*u?^(=g5s[dq<1"&CR+6 BKG[~{dHG|r6*qMvDt5{r`X')W7\Fc|8u\/pIjLW*@]q"j.*Er]Kv$FeC[$:|)FHKv.?RL[cl:y(Y?"@"kJYGc1~Z-8!/UR1Zd"9dqw	TG;<4\P.w{Q;[_dj^n86]ea&Bp!'Vm{LCg
v$'CKj]RO(N]U.HYWwm;2V)Q8fK92mvn&nsy`W_bN
UFI$llz*!j*jFT
,\4`-Gq>iw oPIf2 ,[(Rt9 G;bSYWU>@&bmD<AMY7$/Y=I /;^s-Mq1w-7_ Vcx(zo`+9GaP
bl1d<o+mraG]m*)O2N\|N8mG{xl#]FBB@Eg1-v	VHK@ [
ZX=%'~"#m6T(d7fWC~b3xC"y;pyF "4NWxRg 6!X:SG|x%K5n}&#%~u~=hyWs2&zP(aV2H /Pbn U*!7fBr9a+x8yF7%oT;/XbJ$!<c?O?kTI`a?I d[o$CX%}fW\WwGf~HwWu+aWJ=h]Un`*Pq+|</~	Y UNm4W$#u@X_CGKkp3d`P1O^p5cLiYrV.:dZpbMx7*O814Gr=Yx:Ho<L ]fuReD.fg-\O.C,V~0Al='6WmK4@-]$:# Vi8 `/W} XJufmxWRMN
ZV5e4^m0MudZ"H60er||T'Fb~FAFg]a?%dcYpcJ.I-tz+
TpX(6#<ix@z&>O1^#o$p{c`T8V~z)V]ga
dtt$('+pjwgIq&h0T>d	]#jb]7Y$%hKzN@$0fI)9pNq)b?)uY?0n&e5"*V
 tM+_%K,a\pPZea-`5BmM3r3`NG&D[OoEC$`d*3Z]bd!Q\h)LIImX{)-oj"Kl74[	 `+wg+>"#=1#g8n^1:@_vZVqoR{=LEv!c{k[8x[%6^HwK}Egp^!6m#) P4jr2l 8[B>a'hzxbct&9/nu46=10!hKwehsZ1`vB`Tt?~ulI!z)XOK\4yDr}_oUG/ D)+x}l*0C3,qS>6$cx lX59=4G1yGCkhYX&2V{-^VyAC^\}WF
dB5MUtc63*QAC[owF9B],Z[(!#*WHSr~LcS~s+([r@I(Cwy8P#Ci7xU3z3>r@?hrP[:iZm}3 Dz
zV[v ;JnuMMs6OH'/KTta =Ws1^`XD[B\
AI,`qIsK
3nQ^zQ1#2&TV)(`dQHQ*>d?;39+"s5Yf"V&P, ~GE#)_ :aanHFW&m3"]p\:OtLH	|yak~]	}y\:bs2 p#V+-O8#v	e.wYPu2)NcSY4AW[Z0d,^d<7/zPTW>$Er1nkXDYpvWWA )3_:N]*ked&%d#SqE7'L Wg*"@fT
v2M sz~|])VJ|n8kH4Xq jncBEc,n{rDd'QZE7ZFwjGFrPHlw#%%lXS%SY/ogm+-P-E+CXeW:SSje/O.\ul3s X.Yl0r?+ZddsarxWy*z=g3n>Ge*M1J@KmZx	: sG[Hz Otvu$%EOs ;hx'8h^hra?l=$U{8qhFB>+&	`Qz|T0w*#fQa/d5_ BN>0wG1&B~fE>]!xqF1/}9KfwuD'&xo!5>ukajsJ.WIKf w*B<?|0!WKfAIf+Z_"%QCydMa}Nr	GMHeduL^;65Y~j
m&1lxN{t2NMXuI><vIE.vgF-lW~k;.NVO2                             
              w~                     AR                     |                     ~                     ~                     y                     ,s                     |v                     NV                     I                     )|                     h~                     4                     0!                     5{                     Z                     Pz                     Y                     {                     I{                     w                                                               	y                     }                     
1                     }                                            	                                          `                                          Z~                     y                     |                     '|                     ?                     z                     w0                     QB                     y                     |                     ~                     u                     }                     +{                     ;}                     r                     x                     v                     V                     _Z                     F                     w                     w|                     u                     b~                     M                     /                     `                     x                     k                     r{                                           KG                                          p~                     ~                     1~                     y                                          !                     C                     aY                                                               X                     }                     zg                     9|                     `                     S~                     t                     v                     As                                          }                     ~                     v                                          {                     }{                     1|                     ,z                     }                                          XB                     /v                     U                     r                     .                     ?{                     4w                     '~                     5                     z                     S{                     |                     n|                     }                     Hz                     [~                     D                     }                     R                     	                     sy                     R                     ~                     O|                                          s                                          G|                      w                     |                     |                     Y                     Wi                     z                     {                     tY                                          ;~                     z                     O                     v                     |                                          z                                                               v                     &!                     R                                          {                     p                                          |                     |                     L~                     /R                     `                     ,!                     z                     Zt                                          `O                     /                     @{                     0                                          f                     |                     3                     {                      s                     
}                     |                     s                     x                     ~                     v                     ]{                     ar                     z                     y                     0                     z                     v                     g{                     Uz                                          ~                     
~                     x                     }                     JZ                     }                     }                     }                     u                                          }0                     {                                          }                     8z                     [|                     ~                     D~                     |                     y                     iO                     ~                     t                     y                     /                     v                                          ~                     c|                     ~                     }                     O                     Z                     v                     {                     y                     ~                                          	X                     z                     %s                     ]i                     ,                     |                                           ~                     Y                     {                     y                     O                     {                     u                     J}                     xR                     mv                     4s                     ~                     
|                                          JG                     {                     |                     	u                     v                     t                     
                     _                     K                     ~                     u                     v                     |                     ,{                     }                     a~                     %                                          5                     "                                           *y                     {                     ~                     `}                     _B                      !                     z                                          }                     x                     n                     s{                     (}                     {                     {                     ej                                          Y                     s}                     7   "                   ^v                     "                                          h                     ~                     A                     {                     ~                     U|                     v                     ?                     |                     ix                     ~                     {                     g                                            #y                     |{                     ~                     ;                     Ul                     {                     Iv                     z                     u                     |                     fR                     U                     |                     -                     {j                     x                                          {                     L                     u                     z                     {                     y                     @|                     {                                                               r                     {                     U0                                          y                     |                     S0                     z                     g   
 0            .
    `            <U   
      6          
                 
      R      n   
 	            )?   
      
       
   
 J            q    (,            -u   
 X     <       \   
             Ad   
      4       T   
      f       I   
 e
           ^&   
 b            %   
 b               
 &M     "       %>   
             v5   
      ,       *    p            -   
             ?   
 Z     L          
             [   
 K               
 h            "x   
      "      A    `b            l   
             C   
 	     ,       t    K            {U   
      <           "                
      "       8   
 2]            a   
      H                          
 Xb            Fj    !             V'   
 c     H       xA                
   
 vJ            X   
 =     n       O   
             `   
             ?Q   
 .<     @       0f   
 .            ?   
             C   
 	     $       J@   
            k   
 P     r       ;   
 
0     :      38   
 U           *t   
             [w   
 4            /   
 6     f       r   
 >            y   
 <-     r          
 \2     Z      or   
             L   
 
     :          
 m     B       N#               +                V   
 J     n          
 8n	            8   
 VS            +                    ,               
 j	     T       +                     !             E   
      V       ]N   
 
     x       ("   
 ,O            S7   
 ND     L       	   
 E     P       m   
 z     N       U   
      n       '   
            9O   
            E%   
 v            m_   
             i   
 >}           a         (          
 U            )9   
  t     <       w   
 e     	      I   
 $*     z       $;   
             E   
 L            I   
 
     r       S   
             hH   
 :     n       v   
 n)
              
 !            q   
             $   
 D
            B   
 	     .       5;   
              A!   
 '     6       %b   
 `/     L       c<                D   
 	           7   
 F            :   
 J	     ~          
      6       5   
 L               
 <            1   
 *             7                 o    ]            ]                }   
 "p     Z          
 	             \   
 ^     ^           !                
 3            &   
 pc            :F   
 <
           ;t   
      4       X   
      v       d   
            o   
 v            $   
 r?            8    ~              
 4     &       <               x   
             p   
                
            5   
 <     ,       x9   
 u     .       r   
      &       #u   
      <       \   
 V     B       _   
            R   
 8     :       s   
 |            Q   
               
 9     "       
   
 J               
 Lm     4       M]   
      J       O   
      	      g(   
 Td            	   
  F            0   
 lZ
     Z       ]$   
      >       (`   
 .            Z   
 l            SK   
 |
     D       B   
 	     F       R   
 W               
 i	     ,       \   
 S            hK   
 r
     6       )   
 d                
 *N           5U   
 <     X       -    "             X   
 D            (   
 2L            [z   
 s     `       X!                r$                D   
 <J	     l       |   
 X     F       !j   
 _     *       M   
 
            4   
 	     f       ]   
      f       .-   
 zt            nx   
            q[    X7            9   
      `       i   
 f            <   
 D               
 
            |H   
 @
           X   
 Z      $      7\   
                
             c   
 DJ     8       2   
 X            {    @               P+             F;   
 n     ,       WW   
       @       5   
      J       '   
 *d            @[   
             l   
              k   
 vr     (       >   
               
 H1     p       n   
      F          
 
               
 K            7!   
 &            =   
 ^     <       lb   
 >            @   
 *            b   
      *       {C   
 	     $       j
   
 PH     N       ^   
             Q   
 S     f       8    !             "5   
 
            S   
      R       da   
                
             p   
 F#            F   
 2	     "          
 F            U   
      n       -   
      .       +j   
 `            M   
 
     .          
 jk            %   
 b            |   
 D           5   
             kV   
      X       .    "              
 t     >           "             <               :                a-   
      n       J   
 L            |+                bm   
             tW   
 y     R       g   
 dO     
        N   
                
 $[            
    "             W   
 |B     @       G   
 V     \       h:   
  ~     N       ;               r   
 F     ,          
             m   
 <n               
 >
            a   
 x     H           h4           $   
 ?            i   
 *i     N      .4    E           2   
      >       M   
 
            <   
      "       q,    `            1   
 Z	           g   
 V            'S   
             =_   
 8     4          
 R     Z       J   
 f
     @          
 J            a   
 
            H   
             4    U           HD               d   
                
 t	            8               j    d7            (               S   
      0       o   
 X            ?+    (               
 Y     t       T   
      0       r   
      (       P   
 '           V   
      R       (   
 dd     "       T   
 P     R          
 @k     &       g    h7            :   
             t	                   
      X       Wh   
 8     ~       wV   
 *     X       `   
      
       ?A               =    0           [s   
      $          
 |
            n   
      >       6   
                
 F     h       V   
      ^          
      p       ^T   
 &M     2       L   
 
           x   
             x=   
             1               L   
 
     @       z]   
      J       9   
 w     &       /   
 D            [*                F	   
 Le	           i    !             C   
 	     ,       ;   
 tk     $       H   
 r            rw   
 @     X       ^F   
 9     ~       EU   
      6       w   
      x       .   
 Z                `"             8   
 h     V       O1   
 P                0           13   
      .       S   
      
           
 bP            V   
 J     6       F8   
 >X     J       f   
 .     ,       rq   
 n            Ju   
             E   
 2O	            ]   
            >   
      h       tL   
 
     |       p   
             2    G           x#    x           h   
 k            uL   
 
            j   
      V
      ]V   
      L       nQ   
 6           Z   
      ^           0"             k   
 o     Z       !<   
             6   
 ^
            P   
      >       h   
 Y     
       Db    L             N   
 
               
 L            {\   
      :       (                !   
 |,     v       q   
 F            h   
 X            9M   
 x
           5=   
 .     >           
      N          
 VO            B   
 
	     &          
 |	     &          
 R`            M   
 
           I                =   
 s            5   
 :X     \       .     $           C   
 	     $       1l   
 f            H   
      6       s   
 \            1    g           $   
 
            8   
 N               8"             j    !             b   
             }`   
 @     \      V   
      T       K   
             ]b   
      F          
      8       (                )   
 d                
      ,       {i   
 e               
 T     t       hS   
             ]   
 @     d           
 ,            
   
 H     j       MF   
             O   
      8       j   
             vm   
 zo     f       d   
             RK   
 
           @q   
 `            =    H            H(   
 Ld            T   
 *             (I   
 W
     @       X   
 6L     V       *   
 nk            *                F   
 	                           M   
 p
     p       /   
             O   
            T   
             F   
 	     B                {       Fc   
      h       TC   
 (	     B       D   
 nK	     N       Q/   
      t       S                C   
 4	     .       1   
 :            Ga   
 TW     @          "             iX    x           0   
 "     
       ?   
 p     r       Z   
              5    7            L   
 
           X^   
 J               
 ^Z     N       j   
      
       Nm   
      ,       )                R   
 X     Z          
  [            FC   
 	     T       n   
 B     |          
      (      `    hP           e   
 s     |       i   
 k     N       -   
 <     d       o   
 \                
 p$            l   
 vl     T          
 	     "       A    0O              
 P     4       h   
 Do                
 )           &(   
 Hd            b8   
 Y            $    H              
 O            :   
      R       ?   
 |     .       `   
 ,     n       #               [    
 N
            6   
 :<            =   
      X       u   
             _   
             `t   
 r            y         #      Q`   
      J       >0   
 >                
 b	            L   
      ^          
 L            T    
 B     
       }8    {           D   
 *K	     D       eU   
 x     R       H   
 X               
              k    !                
                            9   
 x            p   
 rY     x       p   
 :            @   
      f         
             >Q   
 d6           Y   
      l       0   
             Vp   
             A   
 d	     v       \1   
 T            C   
 0	     H       Ux   
      2      B   
 	            e   
               
              w7   
 0E     l       +C   
 8	            U   
      L          
 _            "   
 z     2      K   
 
     4       q   
      
       %   
 ha            +                K   
 6
            E   
 r\	     >       R   
 s     Z                       U   
 f     0       O   
      \?   
                 P+             U   
       ^       x   
 `            *    @            u    
 6>            w   
      
      n   
      B        H   
 !
            9   
 v            )                IP   
 F     X         
 @W     Z       G   
      f       ]   
             $   
 k	     H       6Z   
 p            B    hb            k    l7               
               OH   
 +
           SU   
       6       U[   
 l     n       I   
 z
     (       T4    C           q   
      ,       ;   
 D     
       F    
 8     
          
      r       N   
 k            YA               p   
 F     "       y   
 t,     n       "   
      ,       [   
              !   
 $            WD   
 H	            6   
  K     r       !   
 P,     ,       c\    7            3%    h            	t   
 -     ,       ]5   
 ,            &   
 $c     L          
 m     R       <   
 f     j       H   
 >            p!   
 ,            c   
 X     @       6u   
      6       w   
 Y     J      l   
 m            
@   
 
            <#   
 >     $       q   
 z     "       m   
 (     J          
             	J   
 T
     f      s   
 :            N    !             x   
             n   
 V            .   
             b   
               
 f            _   
            X;   
      (          
 h     "       N   
 4
              
 \            ^X               o   
 h            
   
 N^     H       +   
 
	            3   
      .           
 hY     J      w   
 [                           +   
 
!
           4    W           Q   
 @D           D   
 H	     R       d	                <   
 D     ^          
 |p     Z       &   
 tc                            %   
 P            #_   
               
      d       '8   
 Q           5   
 d     &       i   
 d           !   
 %           0   
             ii   
 ]     z      3   
      .            *             =   
      4          
             ^   
 L            	   
 F     H       >   
 8     0       <   
            u   
      v       i   
 Y     \          
 ><     
       
V   
      0       !   
 %            W   
 u     p      C   
 x	     ,       u   
      h       =   
      ,       ,$    @           I=   
 l     0       A)                [   
      \       ]L   
 B
     :       W   
 ,k     	      Oo   
 L            9@   
      ,       N   
 
            Q   
 U     4       ,    X            H   
                
 _     <          
            	   
 4E            rd   
            W   
 j     >          
 U     `          
 4            L    0            "   
                "              U   
      n       h   
      4       eE   
 (\	            }T   
 L     d       Q   
 P0     (      A   
 Z	     6       x   
 	           c9   
 t     >      F   
 H	     h       a   
      
          
 M     "       V   
      n       p   
             c   
             U)                U   
 6     *       g   
 XM     
       c   
 h            i   
 r               
 P              
      @       D   
 FL            pl   
 h     p       A:   
 z            %   
 4b            g+                +U   
      X          
 -            <   
             c   
 Bg            3   
 n            if   
 *               
 K            .E   
 Z	     
       ,    P               
 !            mN   
 
     p      \   
 R>           k    !             <2   
      <          
 |            X   
 rh     X       >   
      4           "             	@   
 @
     l       Z   
 J            l   
 8n            [   
                
 h            >9   
 \t            N   
 ~K            vD   
 H	            KT   
 ,:            pU   
      0       rO   
            v   
      p          
             ;   
      "       W   
 jy     ,       m   
 r            nn   
 :            a    X"             W   
      R       t   
                0           h   
 xj           L   
 
     0      s   
 -     ,       f   
 /     b       O.   
      8           X           i   
 `            -^   
             L   
 
     $          
 J            Yj   
 f`               
                
 K            X   
      l       :   
            q   
             AY    p            	   
 E     >       IR   
 W     "       i   
 	     ^      0   
 \0            b   
      X       ]k   
 d            gu    L               
 HM     "                      ,   
      4       "    8                             
 X               
                
 T            (   
 "S     4          
 L            z;    u              
 .V                h                w           ^   
             C   
 	               
 f     ~                          
 ^     F       ^u   
             6]   
 (           S   
      d       I   
 
     
          
 ,     n       (A               <   
      \       f   
 .     ,          
 N	     p       p?   
                
 h     .       0i   
             Z   
 dm            	   
 ^E     4       g   
 dN            Z   
      "       "   
      ,       ,#   
      R      q   
             __   
      D       R   
 X            ;   
            G   
 0            6`   
 @           Se   
      >       h   
 T_     <       !F   
 U     (                ]          
 Z            Y   
 &Y     L       o   
      8       	     *             M   
 V
     6      Q5   
 (            4   
 	               
                
 v            2y   
 :            2   
 [     ,       W   
 H     "       w   
 l            &Q   
 |1              
 `     \       =   
 N     h       e   
 
            #    X           qI   
 .[
            0   
 ,     
           !             aJ   
 
            V   
      0                       c   
 P              
 S            F   
              91   
      <           q           a#   
 >     $       U   
 z     j       u>                p   
             r   
 8     >       ?&   
 b            ~   
                
 :            rT   
 
                
 *l	     t         
             7r   
 :                 h"             +[   
      :          
 K            e                i0                               `   
      8       :'   
 c     R          
      <       fC   
 j	     Z       
N   
             b                	-    5            H$   
 ,     B       2   
              {@   
      t          "             2   
 2L     H       p   
 K            7g   
 1     2       3   
             K   
 
     @       8"   
 K     .       b   
      B                      +V   
 T     d       k                k2   
                
 M     "       =    !             3   
              -    5            U   
      *       f   
             h   
             6   
 7           b   
      P       oj   
 `     0       `   
      2       U   
 ~     ^       1   
             P   
 %     B      'o   
      8       .   
             7K   
 p
     |       -   
 R            \   
      ~       &   
 J            l   
      6          
      "          
                
      j       u   
      4       m-   
               
  L            6   
 6     b       l   
 ,n            }y   
             O   
             <$               ?B                ;>   
 8     R       RG   
             h   
 V     d       %   
 z               
 X9            ue   
             D   
 @I	     D          
             3   
 N     .          
 
            |J   
 4
               
 <     J      4    L           w   
            _   
                
            D   
 I	     j       a   
      
          
 P	     L          ("                 H"             V   
      R       0G   
                
 !            V   
 t     R       ip   
                
 	            B   
 	     @       ro   
 R            )    P"             &   
             %   
             ]l   
 g     6       E   
 m	     .          
      ,       3.   
 z           n)                 <L   
 

     4       9N   
 
           X   
 F     0       /    x)           3B   
 $	            mG   
 t               
 \            OW   
 t      L       8    H}               `           WI   
 Z
     h       SV   
 V     0       s^   
             ,    H            P   
 /     <           
 n
            6;   
 `     P       $   
 
            N   
 n
     t       
   
 J            Sn   
      <      #               f?   
             n   
            ^   
             P   
      \      M<               d   
 f     D          
             ~K   
 
     @       x   
 I            G   
 P	            6h   
 r           `   
 X            1   
                
 V	            `    !             r'   
  d            &   
 W
              
             1   
      .      '   
 c            Q   
 S               
 &     R       =   
             $         ~       S   
      ,           x"             o   
 b            Hk   
 X     $       W   
 :     @       b   
 PT               
 4a     $      iA    P           ?   
      h          `            V   
      L        .   
      @      '   
 $d            !n   
      J       2   
             x   
      0       G   
 \Q           rs   
      Z       c   
 g     P       *    X            	                 C.   
             I    N           A4   
 ,     (       v   
 60            x   
      x      bx   
 	            +    8            V   
      ^          
      N       l]   
             $/   
             m   
 ^     V       C   
 vK            J   
 ~
     :       Zg   
 ;     @       )                   
 "     b          
              t    !             <s   
                
 	     \       Fg   
 ^9     L       }*                         |                      t   
             "               9-    5            J   
 
               
      "       %   
 
b            I   
 [     ,          
 (m     $       e   
 ~     D       Jh   
 J     2           
 
            <     "             LA                E   
 ,\	     B       H   
 &            [   
 >            g   
 bO                h            tM   
 
     6      u   
             6   
 *:     "      _   
 "            ]   
             S\   
             M6   
 0     L          
  -               
 (	            )   
 "            )2   
 z     R       2   
 zL     F       _    @*           9    xw           mR   
 2X     "       2   
 nD            s   
 (.     ,       +                G/   
 b            tX   
 $     "       0   
      .       R   
 l!     T           
 	               
 q     b       i   
 do            I    X?           )    8                "             (   
 d     "       Jr   
 Z     >       Y0   
 d7     b                       z   
 2            +e   
 	           h`   
 :            
   
 J            S   
             F   
 	     L      U8   
 X            ?   
                
 L     @       Ay   
 vK            @    P               
      
      7   
 E               
      J          
             A               E    p           2a   
      `       V   
 f     L          
 >O     $       X   
 P;     D      ra   
                
 l     h       =e   
 
     n       ':   
 z            ;   
 h     X       Z@   
 Z     t         
            4   
 |K     V            }     |         
 Hg     z       @   
 
           y   
 d            ;   
 t     ,      y   
 0     <
      R   
 TX             &   
 b            >   
      h          
 A           7   
 ><     B       s3   
 Z            T   
      r       '   
 0d            :S   
      :       @    M           PO   
      j      S   
      .       ,   
      D       N:   
 {     Z       "   
 8            :T   
 @           ^   
 ~           Z   
 `            :*                _   
      4         
 /     p       U   
 6     0       AW   
 6      >       T   
      r       9   
 w     h       <               l   
             E   
 zZ	     
       k    `7            t    <            T   
       0       k   
      <      KN   
 
            e7   
 D            w   
 P            -   
            zp   
             (   
 	            5   
      ,       e6   
 5            c>   
 <m     (       PX               0/   
 
            e    `M           El   
 g            ;    `           .   
 Z           w               D   
 M	     v       //   
 
                !                
 1     z       \3   
 ,     .       A   
 #            M2   
             :   
 (     (           p"                                
      .       6   
      d      Lf   
 .               
             LJ   
 
     $       F   
 <	     N       X   
 L     6       
   
 H            #   
 >     $       @
   
 G     F       Q   
 ^     L       \   
 J>               
 @     H       u   
 ~     4       4   
 
                x            \   
 l     >       ^   
 0     ,       D    h            R	    x            .   
      .       Xq   
 b            ;   
            !   
 	     ,       [   
 ~     *          
 v            I   
 
     j       8V   
      R       ]   
            f   
 /     J           
 b$            j   
      ,       K   
 >
     h      u<                8   
 L     :       h   
 PK     &       )    (            E    
            1H   
 d)
     
       f   
 -     F       }z   
 (u            $   
 W            s   
 2            ug   
 >     4       T   
 f+           ^=   
      >       5	   
 6	     B       %p   
             `   
      @       T   
 J     <          
 !               
 R            [   
             w4   
             5   
 h
           Z   
      8       !T   
 p            [   
 N     D          
 6     b       3   
      .       3   
            L   
      >       *+    0            g   
             8n   
 X            G   
      \           (            3   
             6R   
 W            
   
 *G            e   
 (     T       ~u   
 X     <       "   
 M            W   
 B     @          
      ^       ~   
 >             5   
 
     F      6x   
 j            #               ^   
             T   
                 
 
              
      2          
             i   
 -     "       cW   
 y     R          
 :k            U   
 `     R       m%   
 Ba               
 s     8          
 V            8    y           d   
            K   
 
            %   
 
                            gP   
              pF   
 	     p       }P   
             j"   
 	            7   
 G     b         
 U            Sa   
      >       J   
 ZS               
 K            L   
 J
     @       *    P            R    "     0      F   
 	     j       #    h           {6   
 T6            3j   
 `     N       (   
 Dd            W   
 t            a   
      P          
 K            t   
      T       r    @              
      H          
 ([     B       9?               B   
 	            i:   
 {     J       }K   
 
     @      k                p   
 B     6       _   
 ZL     |       *                `   
 d            .c   
 |J            9   
      ~       Z   
 \            }x   
            /   
                
 22     *       G   
 n            O   
             J   
      ,          
              s   
 L            #*                =<   
 ^     R       F   
              J   
 
            Z   
 8     F       
   
 I     f      8                    P     h       ZQ   
 n<     <          
 	     @          
 &            #7   
 <     |          
       ,       `y   
 pr            9   
 y     .       d   
      6       D               K?   
      J          
 r     (       06   
 "     |       fB   
 P	            &]   
      J       j   
 `              
 
              
 @     b         
 F     B       r   
      B       !   
 ,     .       e   
                
            K   
 
               
 p     Z       E               V   
      *       Q   
 R           j   
 _            $                7   
 E     b       #   
 "?     $       D   
 I	     N       /W   
      <       v   
                 
 P           jz   
 <t            W9   
 vt               
 0q     ^       1J   
 R
            H   
             Ii   
 n|            w   
 lm            3P   
 @            J   
 :
     @       Y   
 V     
       A   
 	            Z   
 @            5)   
 d           t    G            K   
 6
     6       9   
      B       qt   
             I   
 
     *          
 J            ^   
 *           "                q.                [R   
 X     *          
 g     X          
 n     D          
 q     v                       &   
 b     P       '   
 	     
       d   
             GE                   
 (            (K   
      ,       n8   
 d     .       j;   
 D            M    8           g    !             W   
      :       .   
 N               
      D       Q
   
 H     @       %   
 a             Ip   
             *                QS   
      :       =   
             ;               4   
      (       l   
 .            ]]   
 V     L       e   
 ~     H       kD   
 H	     &       >   
 h            Q   
 V           -   
 `               
      &          
 F     0       5   
 2     |          
 R9            ]U   
 6     B       V   
      L       ?   
      6         
 B               
 N               
 2     2       b   
 &     v          
                
 _     <           
      T       [   
             ,X   
 x     8         
             _/   
 V	     4       .   
             V   
      L       #   
 F?     ,       Td   
 &            4k   
      N      <5   
      <       8   
 H	            S    (           [   
 Z             @   
             :   
 6y            1Y    p7            $   
      j       j*                     _              
 R7               
 P2     <       &   
 zc            G3   
      .       Hw   
 2     -0   
 l
            ,                S+                 N   
 
     J      #   
      V       o     "             .   
      6      sc    G            /               m   
 ^                
 jM     "       /   
 6     N       U   
      *            y           Nt   
      N       -   
      @      u   
 L     2       3   
 r            $6   
 R     \       V   
      R       :   
 H     T      (   
 \d            _    !             1   
 .     L      2   
      <      =^   
 >            B   
 B	     &       0   
 *X	     f       ?   
       :       !   
 	     <       -<   
      N       6m   
 Dn            M   
 b
           r   
 v                "             ^c   
 D            +,    x            @   
      >       o   
 ~            p   
             S   
             ^e   
 F            0   
 z               
 
	               
 T     .       \   
 $[              
      (       )                Gx   
      P       4   
 |            G   
      \       8               R   
 dX     ,       A   
 vm     .       S   
             =   
       N       R>   
                
 h	            9    h               
 N1                     ]           
 ~$            R   
 FY     TI      #m   
 @n            ,    @            t    K            E                   
 Z     4       A,    p                            "   
 k	     .       s   
      0       ^   
             u/   
      .      v1   
 l           z   
 v               
 =            |B   
 R	     ^       N_   
 l     h       \   
             Y,    h            $R   
 W            1    h:           1   
 (           c   
      v       s   
 $     4           0           m   
 o     &          
 z     6       !Y   
            L"   
 	     >          
 Z            p   
             '   
 6d            j   
      j       uZ   
             	   
 DE               
 n[     N       Y   
 F            
Y   
      t       E   
 m	     `       )                 	   
 =     >       7    f            77   
 TB     L       a   
 &      4       /   
             s   
      r       T%   
 6a               
 =     $           
 *
     8          
                
 Z	     &       u:   
 n~            IV   
 
     L       O    x               
 Z     *       r   
 z     $       QM   
 
           AX   
      F       h4    xN           ,   
 B     B       C   
      R       :   
      .      M   
      4       `    !             ,q   
 R     
          
 
	                            `   
 r            U   
      .       z   
 [
            Js   
 `            J                   
                 !             mk   
 d            G   
 V            J   
 \
            g   
      P       U   
      j       }   
 f            N                o   
 p            >   
 N     .       =6   
 pj	                @"             Ly   
 L            j   
 n     L          
 <     "       0D   
 XQ	           R-   
 x     h       e   
 h     L       e    
 L     r          
 fr     (       9I   
 *Z
     B       w   
 h     4       9   
 ,c           h   
 V            I*                t   
 z     4          
 h	            j   
 b_     n          
 \
     
       9   
 RU     N       ^   
            "@   
      ,       o   
 n               
 @     X       -   
 r     f       X   
             d   
             2   
             q    
               
 09     "       D   
 M	            6p   
             k   
      r       n   
 D     V       ?   
 xp     ~          
 j           kh   
                 `&           E   
 k	             _ITM_deregisterTMCloneTable _ITM_registerTMCloneTable __cxa_finalize _Py_hgversion _Py_hgidentifier Py_GetBuildInfo PyOS_snprintf PyGrammar_AddAccelerators PyObject_Malloc stderr fputs PyGrammar_FindDFA PyObject_Free PyGrammar_RemoveAccelerators PyGrammar_LabelRepr _PyParser_TokenNames Py_FatalError fputc fprintf PyNode_ListTree stdout PyNode_New PyNode_AddChild PyObject_Realloc PyNode_Free _PyNode_SizeOf PyParser_New PyMem_Malloc PyMem_Free PyParser_Delete PyParser_AddToken _Py_newbitset _Py_delbitset _Py_addbit _Py_samebitset _Py_mergebitset _Py_meta_grammar Py_DebugFlag _Py_findlabel _Py_addfirstsets _Py_newgrammar _Py_adddfa strdup _Py_addstate _Py_addarc _Py_addlabel _Py_translatelabels __ctype_b_loc PyToken_OneChar PyToken_TwoChars PyToken_ThreeChars _Py_pgen putchar PyOS_InputHook _PyOS_ReadlineTState __errno_location clearerr fgets feof PyEval_RestoreThread PyErr_CheckSignals PyEval_SaveThread PyOS_InterruptOccurred PyOS_StdioReadline PyMem_RawMalloc fflush PyMem_RawFree PyMem_RawRealloc PyExc_OverflowError PyErr_SetString PyErr_NoMemory PyOS_Readline _PyThreadState_Current PyExc_RuntimeError PyOS_ReadlineFunctionPointer PyThread_allocate_lock PyThread_acquire_lock PyThread_release_lock memcpy PyTokenizer_Free PyTokenizer_Get PyParser_ParseStringObject PyTokenizer_FromUTF8 PyErr_Occurred PyUnicode_FromString PyTokenizer_FromString PyParser_ParseStringFlagsFilenameEx PyUnicode_DecodeFSDefault PyParser_ParseStringFlagsFilename PyParser_ParseString PyParser_ParseStringFlags PyParser_ParseFileObject PyTokenizer_FromFile PyParser_ParseFileFlagsEx PyParser_ParseFileFlags PyParser_ParseFile PyUnicode_Decode PyImport_ImportModuleNoBlock ftell PyExc_OSError PyErr_SetFromErrnoWithFilename lseek64 _Py_FalseStruct _Py_NoneStruct _PyObject_CallMethodId _PyObject_GetAttrId PyObject_CallObject ungetc _IO_getc PyMem_Realloc _Py_ctype_table PyExc_SyntaxError PyErr_Format PySys_FormatStderr PyUnicode_Type PyUnicode_AsUTF8AndSize PyByteArray_AsString PyByteArray_FromStringAndSize Py_UniversalNewlineFgets stdin PySys_WriteStderr PyObject_Size PyBytes_AsString PyUnicode_DecodeUTF8 PyExc_UnicodeDecodeError PyErr_ExceptionMatches PyErr_Clear _PyUnicode_Ready PyUnicode_IsIdentifier PyTokenizer_FindEncodingFilename _Py_dup fdopen fclose PyTokenizer_FindEncoding _Py_add_one_to_index_F _Py_add_one_to_index_C _Py_NotImplementedStruct PyType_IsSubtype PyTuple_New PyExc_SystemError PyExc_TypeError PyExc_AttributeError PyObject_Type _PyObject_HasLen PyObject_GetBuffer PyBuffer_IsContiguous PyBuffer_GetPointer PyBuffer_FromContiguous PyBuffer_FillContiguousStrides PyBuffer_FillInfo PyExc_BufferError PyBuffer_Release PyObject_CheckReadBuffer PyObject_AsReadBuffer PyObject_AsCharBuffer PyObject_AsWriteBuffer PyObject_CopyData PyNumber_Check PyNumber_Or PyNumber_Xor PyNumber_And PyNumber_Lshift PyNumber_Rshift PyNumber_Subtract PyNumber_Divmod PyNumber_Add PyNumber_MatrixMultiply PyNumber_FloorDivide PyNumber_TrueDivide PyNumber_Remainder PyNumber_Power PyNumber_InPlaceOr PyNumber_InPlaceXor PyNumber_InPlaceAnd PyNumber_InPlaceLshift PyNumber_InPlaceRshift PyNumber_InPlaceSubtract PyNumber_InPlaceFloorDivide PyNumber_InPlaceTrueDivide PyNumber_InPlaceAdd PyNumber_InPlaceMatrixMultiply PyNumber_InMatrixMultiply PyNumber_InPlaceRemainder PyNumber_InPlacePower PyNumber_Negative PyNumber_Positive PyNumber_Invert PyNumber_Absolute PyNumber_Index PyLong_Type PyExc_DeprecationWarning PyErr_WarnFormat PyNumber_AsSsize_t PyLong_AsSsize_t PyErr_GivenExceptionMatches _PyLong_Sign PyNumber_Multiply PyNumber_InPlaceMultiply PyNumber_Long _PyLong_FromNbInt _PyObject_LookupSpecial PyEval_CallObjectWithKeywords PyLong_FromUnicodeObject _PyLong_FromBytes PyByteArray_Type _PyByteArray_empty_string PyBytes_FromStringAndSize PyNumber_Float PyFloat_Type PyFloat_FromDouble PyFloat_FromString PyNumber_ToBase _PyLong_Format PyExc_ValueError PySequence_Check PySequence_Size PySequence_Length PySequence_Concat PySequence_Repeat PyLong_FromSsize_t PySequence_InPlaceConcat PySequence_InPlaceRepeat PySequence_GetItem PyObject_GetItem PyExc_IndexError PySequence_GetSlice _PySlice_FromIndices PySequence_SetItem PyObject_SetItem PySequence_DelItem PyObject_DelItem PyObject_DelItemString PySequence_SetSlice PySequence_DelSlice PySequence_List PyList_New _PyList_Extend PyMapping_Check PyMapping_Size PyObject_Length PyMapping_Length PyMapping_GetItemString PyMapping_SetItemString PyMapping_HasKeyString PyMapping_HasKey _Py_CheckFunctionResult PyErr_Fetch _PyErr_ChainExceptions PyObject_Call _Py_CheckRecursionLimit _Py_CheckRecursiveCall PyCallable_Check _Py_VaBuildValue_SizeT Py_VaBuildValue PyObject_CallFunction _PyObject_CallFunction_SizeT PyObject_CallMethod PyObject_GetAttrString _PyObject_CallMethod_SizeT _PyObject_CallMethodId_SizeT PyObject_CallMethodObjArgs PyObject_GetAttr _PyObject_CallMethodIdObjArgs PyObject_CallFunctionObjArgs PyObject_LengthHint PyObject_Format PyUnicode_New PyObject_IsInstance PyType_Type PyObject_IsTrue PyObject_IsSubclass _PyObject_RealIsInstance _PyObject_RealIsSubclass PyObject_GetIter PySeqIter_New _PyObject_NextNotImplemented PySequence_Fast PyList_Type PyTuple_Type PyMapping_Keys PyDict_Type PyDict_Keys PyMapping_Items PyDict_Items PyMapping_Values PyDict_Values PyIter_Next PyExc_StopIteration PySequence_Tuple PyList_AsTuple _PyTuple_Resize _PySequence_IterSearch PyObject_RichCompareBool PySequence_Count PySequence_Contains PySequence_In PySequence_Index _Py_FreeCharPArray _PySequence_BytesToCharpArray PyUnicode_FromStringAndSize PyUnicode_Join PyList_SetSlice PyList_Append _PyAccu_Init _PyAccu_Accumulate _PyAccu_FinishAsList _PyAccu_Finish _PyAccu_Destroy _Py_TrueStruct PyUnicode_InternFromString PyBool_FromLong PyArg_ParseTupleAndKeywords PyBool_Type _Py_bytes_isspace _Py_bytes_isalpha _Py_bytes_isalnum _Py_bytes_isdigit _Py_bytes_islower _Py_bytes_isupper _Py_bytes_istitle _Py_bytes_lower _Py_ctype_tolower _Py_bytes_upper _Py_ctype_toupper _Py_bytes_title _Py_bytes_capitalize _Py_bytes_swapcase _Py_bytes_maketrans _Py_maketrans__doc__ _Py_swapcase__doc__ _Py_capitalize__doc__ _Py_title__doc__ _Py_upper__doc__ _Py_lower__doc__ _Py_istitle__doc__ _Py_isupper__doc__ _Py_islower__doc__ _Py_isdigit__doc__ _Py_isalnum__doc__ _Py_isalpha__doc__ _Py_isspace__doc__ PyLong_FromLong memset _PyArg_ParseTuple_SizeT _Py_strhex _PyArg_ParseTupleAndKeywords_SizeT PyUnicode_GetDefaultEncoding PyUnicode_FromEncodedObject PyUnicode_DecodeLatin1 _Py_BuildValue_SizeT _PyErr_BadInternalCall PyByteArrayIter_Type _PyObject_GC_New _PyGC_generation0 Py_hexdigits PyUnicode_DecodeASCII Py_BytesWarningFlag PyExc_BytesWarning PyErr_WarnEx PyErr_Print PyObject_GC_Del PyLong_AsLong memchr memrchr _PyObject_GetBuiltin PyUnicode_FromUnicode _PyEval_SliceIndex PyByteArray_Fini PyByteArray_Init PyByteArray_FromObject PyBytes_FromString _PyBytes_Format _PyObject_New PyByteArray_Concat PyArg_UnpackTuple PyList_Reverse PyBytes_Type PySlice_Type PySlice_GetIndicesEx PyByteArray_Size PyByteArray_Resize PyUnicode_AsEncodedString PyBuffer_ToContiguous _PyArg_Parse_SizeT memmove PyObject_GenericGetAttr PyObject_SelfIter PyType_GenericAlloc PyType_GenericNew PyErr_BadArgument _Py_HashBytes PyObject_Calloc PyTuple_GetItem PyBytesIter_Type PyBytes_Size PyBytes_AsStringAndSize PyBytes_Repr _PyBytes_Join _PyBytes_Resize PyBytes_FromFormatV sprintf PyBytes_FromFormat _PyLong_AsInt PyObject_ASCII _PyUnicode_FormatLong PyFloat_AsDouble PyOS_double_to_string PyLong_AsLongAndOverflow PyBytes_DecodeEscape PyBytes_FromObject PyBytes_Concat PyBytes_ConcatAndDel PyBytes_Fini PyBaseObject_Type PyCell_Type PyObject_RichCompare PyUnicode_FromFormat PyCell_New PyCell_Get PyCell_Set PyEval_GetBuiltins _PyDict_GetItemId Py_BuildValue PyTuple_Size PyObject_Hash PyObject_ClearWeakRefs PyMethod_Type PyInstanceMethod_Type _PyType_Lookup PyType_Ready PyMethod_Function PyMethod_Self PyMethod_New _PyArg_NoKeywords PyMethod_ClearFreeList PyMethod_Fini _PyMethod_DebugMallocStats _PyDebugAllocatorStats PyInstanceMethod_New PyInstanceMethod_Function PyObject_GenericSetAttr PyUnicode_InternInPlace _PyUnicode_Copy PyCode_Type PyCode_New PyObject_Init PyUnicode_Compare PyArg_ParseTuple PyCode_NewEmpty PyCode_Addr2Line _PyCode_CheckLineNumber PyComplex_Type _PyUnicode_TransformDecimalAndSpaceToASCII PyOS_string_to_double _PyUnicodeWriter_Init _PyComplex_FormatAdvancedWriter _PyUnicodeWriter_Dealloc _PyUnicodeWriter_Finish _Py_HashDouble PyLong_AsDouble _Py_c_sum _Py_c_diff _Py_c_neg _Py_c_prod _Py_c_quot _Py_c_pow hypot atan2 log sincos _Py_c_abs PyComplex_FromCComplex PyExc_ZeroDivisionError PyComplex_FromDoubles PyComplex_RealAsDouble PyComplex_ImagAsDouble PyComplex_AsCComplex _PyType_GetTextSignatureFromInternalDoc _PyType_GetDocFromInternalDoc PyObject_Str PyDict_Size _Py_HashPointer PyObject_GC_UnTrack _PyTrash_thread_destroy_chain _PyTrash_thread_deposit_object PyProperty_Type _PyObject_SetAttrId PyExc_Exception PyCFunction_NewEx PyTuple_GetSlice PyMember_GetOne PyDictProxy_Type _PyMethodWrapper_Type _PyObject_IsAbstract PyMember_SetOne PyDescr_NewMethod PyMethodDescr_Type PyDescr_NewClassMethod PyClassMethodDescr_Type PyDescr_NewMember PyMemberDescr_Type PyDescr_NewGetSet PyGetSetDescr_Type PyDescr_NewWrapper PyWrapperDescr_Type PyDictProxy_New PyWrapper_New PyTuple_Pack PyReversed_Type PyEnum_Type PyDict_GetItemString PyDict_DelItemString PyExc_BlockingIOError _Py_ascii_whitespace _PyUnicode_IsWhitespace PyUnicode_Tailmatch PyUnicode_Substring PyUnicode_ReadChar PyTraceBack_Type PyObject_SetAttr PyObject_Repr PyUnicode_FindChar PyExc_MemoryError PyDict_GetItem PyException_GetTraceback PyException_SetTraceback PyException_GetCause PyException_SetCause PyException_GetContext PyException_SetContext PyUnicodeEncodeError_GetEncoding PyUnicodeDecodeError_GetEncoding PyUnicodeEncodeError_GetObject PyUnicodeDecodeError_GetObject PyUnicodeTranslateError_GetObject PyUnicodeEncodeError_GetStart PyUnicodeDecodeError_GetStart PyUnicodeTranslateError_GetStart PyUnicodeEncodeError_SetStart PyUnicodeDecodeError_SetStart PyUnicodeTranslateError_SetStart PyUnicodeEncodeError_GetEnd PyUnicodeDecodeError_GetEnd PyUnicodeTranslateError_GetEnd PyUnicodeEncodeError_SetEnd PyUnicodeDecodeError_SetEnd PyUnicodeTranslateError_SetEnd PyUnicodeEncodeError_GetReason PyUnicodeDecodeError_GetReason PyUnicodeTranslateError_GetReason PyUnicodeEncodeError_SetReason PyUnicodeDecodeError_SetReason PyUnicodeTranslateError_SetReason PyUnicodeEncodeError_Create PyExc_UnicodeEncodeError PyUnicodeDecodeError_Create PyExc_UnicodeTranslateError _PyUnicodeTranslateError_Create _PyExc_Init PyExc_BaseException PyExc_StopAsyncIteration PyExc_GeneratorExit PyExc_SystemExit PyExc_KeyboardInterrupt PyExc_ImportError PyExc_EOFError PyExc_RecursionError PyExc_NotImplementedError PyExc_NameError PyExc_UnboundLocalError PyExc_IndentationError PyExc_TabError PyExc_LookupError PyExc_KeyError PyExc_UnicodeError PyExc_AssertionError PyExc_ArithmeticError PyExc_FloatingPointError PyExc_ReferenceError PyExc_Warning PyExc_UserWarning PyExc_PendingDeprecationWarning PyExc_SyntaxWarning PyExc_RuntimeWarning PyExc_FutureWarning PyExc_ImportWarning PyExc_UnicodeWarning PyExc_ResourceWarning PyExc_ConnectionError PyExc_BrokenPipeError PyExc_ChildProcessError PyExc_ConnectionAbortedError PyExc_ConnectionRefusedError PyExc_ConnectionResetError PyExc_FileExistsError PyExc_FileNotFoundError PyExc_IsADirectoryError PyExc_NotADirectoryError PyExc_InterruptedError PyExc_PermissionError PyExc_ProcessLookupError PyExc_TimeoutError PyModule_GetDict PyDict_SetItemString PyExc_EnvironmentError PyExc_IOError PyDict_New PyExc_RecursionErrorInst PyDict_SetItem _PyExc_Fini _PyErr_TrySetFromCause PyErr_Restore PyErr_NormalizeException _PyObject_GetDictPtr PyUnicode_FromFormatV PyObject_GenericGetDict PyObject_GenericSetDict PyCoro_Type PyErr_SetNone PyEval_EvalFrameEx PyErr_SetObject _PyGen_Send PyObject_CallFinalizerFromDealloc _PyCoroWrapper_Type PyGen_Type PyErr_WriteUnraisable _PyGen_Finalize _PyGen_FetchStopIterationValue PyGen_NewWithQualName PyGen_New PyGen_NeedsFinalizing _PyCoro_GetAwaitableIter PyCoro_New _PyUnicode_AsUTF8String _Py_write PyFile_FromFd PyImport_ImportModule PyFile_GetLine PyFile_WriteObject PyFile_WriteString PyObject_AsFileDescriptor flockfile getc_unlocked funlockfile PyFile_NewStdPrinter PyStdPrinter_Type _PyFloat_FormatAdvancedWriter PyUnicode_AsUTF8 _Py_parse_inf_or_nan ldexp _PyLong_NumBits _Py_SwappedOp frexp modf PyLong_FromDouble _PyUnicode_FromASCII floor fmod PyFloat_GetMax PyFloat_GetMin PyFloat_GetInfo PyStructSequence_New PyErr_SetFromErrno round _PyFloat_Init PyStructSequence_InitType2 PyFloat_ClearFreeList PyFloat_Fini _PyFloat_DebugMallocStats _PyFloat_Pack4 _PyFloat_Pack8 _PyFloat_Unpack4 _PyFloat_Unpack8 PyFrame_GetLineNumber _PyFrame_Init PyFrame_New PyModule_Type PyFrame_Type _PyObject_GC_NewVar _PyObject_GC_Resize PyFrame_BlockSetup PyFrame_BlockPop PyFrame_FastToLocalsWithError PyFrame_FastToLocals PyFrame_LocalsToFast PyFrame_ClearFreeList PyFrame_Fini _PyFrame_DebugMallocStats PyEval_EvalCodeEx PyFunction_NewWithQualName PyFunction_Type PyFunction_New PyFunction_GetCode PyFunction_GetGlobals PyFunction_GetModule PyFunction_GetDefaults PyFunction_SetDefaults PyFunction_GetKwDefaults PyFunction_SetKwDefaults PyFunction_GetClosure PyFunction_SetClosure PyFunction_GetAnnotations PyFunction_SetAnnotations PyClassMethod_New PyClassMethod_Type PyStaticMethod_New PyStaticMethod_Type PySeqIter_Type PyCallIter_New PyCallIter_Type PyListRevIter_Type PyObject_GC_Track PyListIter_Type Py_ReprEnter _PyUnicodeWriter_WriteChar Py_ReprLeave _PyUnicodeWriter_WriteASCIIString _PyUnicodeWriter_WriteStr PyList_ClearFreeList PyList_Fini _PyList_DebugMallocStats PyList_Size PyList_GetItem PyList_SetItem PyList_Insert PyList_GetSlice PyList_Sort PyObject_HashNotImplemented _PyUnicodeWriter_PrepareInternal _PyLong_FormatAdvancedWriter _PyLong_New _PyLong_Copy PyTuple_SetItem PyLong_FromUnsignedLong PyLong_AsUnsignedLong PyLong_AsSize_t PyLong_AsUnsignedLongMask _PyLong_FromByteArray PyUnicode_CompareWithASCIIString PyObject_Bytes _PyLong_AsByteArray PyLong_FromVoidPtr PyLong_AsVoidPtr PyLong_FromLongLong PyLong_FromUnsignedLongLong PyLong_FromSize_t PyLong_AsLongLong PyLong_AsUnsignedLongLong PyLong_AsUnsignedLongLongMask PyLong_AsLongLongAndOverflow _PyLong_FormatWriter PyLong_FromString _PyLong_DigitValue PyLong_FromUnicode _PyLong_Frexp _PyLong_GCD _PyLong_DivmodNear PyLong_GetInfo _PyLong_Init PyLong_Fini _PyDict_SizeOf PyDictIterItem_Type PyDictIterKey_Type PyDictIterValue_Type _PyDictView_Intersect PySet_New PySet_Type PyFrozenSet_Type PyDictKeys_Type PyDictItems_Type _PyErr_SetKeyError PyDict_ClearFreeList _PyDict_DebugMallocStats PyDict_Fini _PyDict_MaybeUntrack _PyDict_NewPresized _PyDict_GetItem_KnownHash PyDict_GetItemWithError _PyDict_GetItemIdWithError _PyUnicode_FromId _PyDict_LoadGlobal _PyDict_SetItem_KnownHash PyDict_DelItem _PyDict_DelItem_KnownHash PyDict_Clear _PyDict_HasOnlyStringKeys _PyDict_Next _PyDict_Pop _PyDict_FromKeys _PySet_NextEntry PyDict_MergeFromSeq2 PyDict_Merge PyDict_Update PyArg_ValidateKeywordArguments _PyObject_HasAttrId PyDict_Copy PyDict_SetDefault _PyDict_KeysSize _PyDict_Contains _PyDict_SetItemId _PyDict_DelItemId _PyDictView_New PyDictValues_Type _PyDict_NewKeysForClass _PyObjectDict_SetItem _PyDictKeys_DecRef PyODictIter_Type PyODictItems_Type PyODictValues_Type PyODictKeys_Type PyODict_Type PyODict_New PyODict_SetItem PyODict_DelItem _PyManagedBuffer_Type PyMemoryView_Type _Py_EllipsisObject PyMemoryView_FromMemory PyMemoryView_FromBuffer PyMemoryView_FromObject PyMemoryView_GetContiguous PyCFunction_Call PyCFunction_Type PyCFunction_New PyCFunction_GetFunction PyCFunction_GetSelf PyCFunction_GetFlags PyCFunction_ClearFreeList PyCFunction_Fini _PyCFunction_DebugMallocStats Py_VerboseFlag PyModuleDef_Init PyModuleDef_Type PyModule_NewObject PyModule_New PyModule_SetDocString PyModule_GetNameObject PyModule_AddFunctions PyObject_SetAttrString PyModule_Create2 PyThreadState_Get _Py_PackageContext PyModule_FromDefAndSpec2 PyModule_GetName PyModule_ExecDef PyModule_GetFilenameObject PyModule_GetFilename PyModule_GetDef PyModule_GetState _PyModule_ClearDict _PyModule_Clear _PyNamespace_Type _PyNamespace_New Py_IncRef Py_DecRef PyObject_InitVar _PyObject_NewVar PyObject_CallFinalizer _Py_BreakPoint PyObject_Print ferror fwrite _PyObject_Dump PyGILState_Ensure PyGILState_Release _PyUnicode_AsASCIIString PyObject_HasAttrString PyObject_HasAttr PyImport_Import _PyObject_GenericGetAttrWithDict _PyObject_GenericSetAttrWithDict PyObject_Not PyObject_Dir PyEval_GetLocals _Py_ReadyTypes _PyWeakref_RefType _PyWeakref_CallableProxyType _PyWeakref_ProxyType _PyNone_Type _PyNotImplemented_Type PySuper_Type PyRange_Type PyEllipsis_Type PyCapsule_Type PyLongRangeIter_Type _PyObject_DebugTypeStats _PyTuple_DebugMallocStats PyThreadState_GetDict _PyTrash_deposit_object _PyTrash_delete_later _PyTrash_destroy_chain _PyTrash_delete_nesting _Py_Dealloc _Py_abstract_hack munmap mmap64 calloc PyMem_SetupDebugHooks PyMem_GetAllocator PyMem_SetAllocator PyObject_GetArenaAllocator PyObject_SetArenaAllocator PyMem_RawCalloc PyMem_Calloc _PyMem_RawStrdup _PyMem_Strdup _Py_GetAllocatedBlocks _PyObject_DebugMallocStats PyCapsule_New PyCapsule_IsValid PyCapsule_GetPointer PyCapsule_GetName PyCapsule_GetDestructor PyCapsule_GetContext PyCapsule_SetPointer PyCapsule_SetName PyCapsule_SetDestructor PyCapsule_SetContext PyCapsule_Import PyRangeIter_Type _PySlice_GetLongIndices PySetIter_Type PySet_ClearFreeList PySet_Fini PyFrozenSet_New PySet_Size PySet_Clear PySet_Contains PySet_Discard PySet_Add PySet_Pop _PySet_Update _PySet_Dummy PySlice_Fini PySlice_New PySlice_GetIndices PyStructSequence_SetItem PyStructSequence_GetItem PyStructSequence_UnnamedField PyStructSequence_InitType PyStructSequence_NewType _PyStructSequence_Init PyTupleIter_Type _PyTuple_MaybeUntrack PyTuple_ClearFreeList PyTuple_Fini _PyObject_GC_Malloc _PyWeakref_ClearRef _PyUnicode_CompareWithId PyUnicode_Contains PyWeakref_NewRef PyEval_CallMethod PyType_Modified PyType_ClearCache _PyType_Fini PyType_GetFlags _PyType_CalculateMetaclass PyType_GetSlot _PyType_LookupId PyType_FromSpecWithBases PyType_FromSpec _Py_Mangle PyEval_GetGlobals _PyUnicode_ToDecimalDigit wmemcmp _PyUnicode_IsCaseIgnorable _PyUnicode_IsCased _PyUnicode_ToLowerFull _PyUnicode_ToUpperFull _PyUnicode_IsUppercase _PyUnicode_IsLowercase _PyUnicode_ToTitleFull _PyUnicode_ToFoldedFull PyCodec_StrictErrors PyUnicode_GetMax _PyUnicode_FastCopyCharacters PyUnicode_CopyCharacters PyCodec_LookupError PyUnicode_RichCompare _PyUnicode_IsPrintable _PyUnicode_IsAlpha _PyUnicode_IsDecimalDigit _PyUnicode_IsDigit _PyUnicode_IsNumeric _PyUnicode_IsTitlecase PyUnicodeIter_Type PyUnicode_Resize _PyUnicode_ClearStaticStrings PyUnicode_FromKindAndData _PyUnicode_FindMaxChar _PyUnicode_AsKind PyUnicode_AsUCS4 PyUnicode_AsUCS4Copy PyUnicode_FromWideChar wcslen PyUnicode_FromOrdinal PyUnicode_FromObject PyUnicode_Concat _Py_normalize_encoding PyUnicode_AsUnicodeAndSize PyUnicode_AsWideChar PyUnicode_AsWideCharString PyUnicode_AsUnicode PyUnicode_GetSize PyUnicode_GetLength PyUnicode_WriteChar PyUnicode_AsDecodedObject PyCodec_Decode PyUnicode_AsDecodedUnicode PyUnicode_AsEncodedObject PyCodec_Encode PyUnicode_AsEncodedUnicode _PyUnicode_EncodeUTF7 PyUnicode_EncodeUTF8 _PyUnicode_EncodeUTF32 PyUnicode_AsUTF32String _PyUnicode_EncodeUTF16 PyUnicode_AsUTF16String PyUnicode_AsUnicodeEscapeString PyUnicode_EncodeUnicodeEscape PyUnicode_AsRawUnicodeEscapeString PyUnicode_EncodeRawUnicodeEscape PyUnicode_EncodeLatin1 _PyUnicode_AsLatin1String PyUnicode_EncodeASCII _PyCodec_EncodeText PyUnicode_Encode PyUnicode_BuildEncodingMap _PyUnicode_EncodeCharmap PyUnicode_AsCharmapString PyUnicode_TransformDecimalToASCII PyUnicode_EncodeDecimal _PyUnicode_InsertThousandsGrouping PyUnicode_Count PyUnicode_Find _PyUnicode_FastFill PyUnicode_Fill PyUnicode_Splitlines _PyUnicode_IsLinebreak PyUnicode_Append PyUnicode_AppendAndDel _PyUnicode_IsXidStart _PyUnicode_IsXidContinue _PyUnicode_XStrip PyUnicode_Replace PyUnicode_Split PyUnicode_Partition PyUnicode_RPartition PyUnicode_RSplit _PyUnicodeWriter_WriteSubstring _PyUnicodeWriter_WriteLatin1String PyUnicode_DecodeUTF7Stateful PyUnicode_DecodeUTF7 PyUnicode_DecodeUTF8Stateful PyUnicode_EncodeLocale Py_EncodeLocale wcstombs strerror Py_DecodeLocale PyUnicode_EncodeFSDefault Py_FileSystemDefaultEncoding PyUnicode_FSConverter PyUnicode_DecodeLocaleAndSize mbstowcs mbrtowc PyUnicode_DecodeLocale PyUnicode_DecodeUTF32Stateful PyUnicode_DecodeUTF32 PyUnicode_DecodeUTF16Stateful PyUnicode_DecodeUTF16 PyUnicode_DecodeUnicodeEscape PyUnicode_DecodeRawUnicodeEscape _PyUnicode_DecodeUnicodeInternal _PyCodec_DecodeText PyUnicode_DecodeFSDefaultAndSize PyUnicode_FSDecoder PyUnicode_DecodeCharmap _PyUnicode_TranslateCharmap PyUnicode_Translate _PyUnicode_FormatAdvancedWriter PyUnicode_Format _PyUnicode_Init PyUnicode_ClearFreeList _PyUnicode_Fini PyUnicode_InternImmortal _Py_ReleaseInternedUnicodeStrings Py_UNICODE_strlen Py_UNICODE_strcpy Py_UNICODE_strncpy Py_UNICODE_strcat Py_UNICODE_strcmp Py_UNICODE_strncmp Py_UNICODE_strchr Py_UNICODE_strrchr PyUnicode_AsUnicodeCopy PyInit__string _PyUnicode_TypeRecords _PyUnicode_ToNumeric _PyUnicode_ToTitlecase _PyUnicode_ExtendedCase _PyUnicode_ToDigit _PyUnicode_ToUppercase _PyUnicode_ToLowercase _PyWeakref_GetWeakrefCount PyWeakref_NewProxy PyWeakref_GetObject PyImport_GetModuleDict _PySys_GetObjectId _Py_DisplaySourceLine PyErr_Warn PyErr_WarnExplicitObject PyErr_WarnExplicit PyErr_WarnExplicitFormat _PyWarnings_Init PyModule_AddObject PyArena_AddPyObject _Py_Module PyArena_Malloc _Py_Interactive _Py_Expression _Py_Suite _Py_FunctionDef _Py_AsyncFunctionDef _Py_ClassDef _Py_Return _Py_Delete _Py_Assign _Py_AugAssign _Py_For _Py_AsyncFor _Py_While _Py_If _Py_With _Py_AsyncWith _Py_Raise _Py_Try _Py_Assert _Py_Import _Py_ImportFrom _Py_Global _Py_Nonlocal _Py_Expr _Py_Pass _Py_Break _Py_Continue _Py_BoolOp _Py_BinOp _Py_UnaryOp _Py_Lambda _Py_IfExp _Py_Dict _Py_Set _Py_ListComp _Py_SetComp _Py_DictComp _Py_GeneratorExp _Py_Await _Py_Yield _Py_YieldFrom _Py_Compare _Py_Call _Py_Num _Py_Str _Py_Bytes _Py_NameConstant _Py_Ellipsis _Py_Attribute _Py_Subscript _Py_Starred _Py_Name _Py_List _Py_Tuple _Py_Slice _Py_ExtSlice _Py_Index _Py_comprehension _Py_ExceptHandler _Py_arguments _Py_arg _Py_keyword _Py_asdl_seq_new _Py_asdl_int_seq_new _Py_alias _Py_withitem PyInit__ast PyModule_AddIntConstant PyAST_mod2obj PyAST_obj2mod PyAST_Check PyErr_ProgramTextObject PyOS_strtoul PyOS_strtol PyAST_Validate PyAST_FromNodeObject PyAST_FromNode PyFilter_Type PyMap_Type PyZip_Type PyArg_Parse PyImport_ImportModuleLevelObject PyEval_EvalCode PyEval_MergeCompilerFlags PyRun_StringFlags PyArena_New PyArena_Free PyAST_CompileObject Py_CompileStringObject _PyBuiltin_Init Py_OptimizeFlag Py_HasFileSystemDefaultEncoding pthread_mutex_init pthread_cond_init pthread_mutex_lock pthread_cond_signal pthread_mutex_unlock pthread_cond_wait PyEval_GetCallStats _PyEval_SetSwitchInterval _PyEval_GetSwitchInterval PyEval_ThreadsInitialized _PyEval_FiniThreads pthread_cond_destroy pthread_mutex_destroy PyEval_ReleaseLock PyEval_ReleaseThread PyThreadState_Swap _PyEval_SignalAsyncExc gettimeofday pthread_cond_timedwait PyEval_InitThreads PyThread_get_thread_ident PyEval_AcquireLock PyEval_AcquireThread PyEval_ReInitThreads _PyThreadState_DeleteExcept _Py_Finalizing PyThread_exit_thread Py_AddPendingCall Py_MakePendingCalls Py_GetRecursionLimit Py_SetRecursionLimit _PyEval_CallTracing PyEval_SetProfile PyEval_SetTrace _PyEval_SetCoroutineWrapper _PyEval_GetCoroutineWrapper PyEval_GetFrame _PyThreadState_GetFrame PyEval_GetFuncName PyEval_GetFuncDesc PyTraceBack_Here PyEval_EvalFrame PyST_GetScope PySymtable_Lookup PyCompile_OpcodeStackEffect PyCode_Optimize PyFuture_FromASTObject PySymtable_Free PySymtable_BuildObject PyAST_CompileEx PyNode_Compile PyAST_Compile _PyCodec_Forget _PyCodecInfo_GetIncrementalDecoder _PyCodecInfo_GetIncrementalEncoder PyCodec_RegisterError PyCodec_Register _PyCodec_Lookup PyCodec_KnownEncoding PyCodec_Encoder PyCodec_Decoder PyCodec_IncrementalEncoder PyCodec_IncrementalDecoder PyCodec_StreamReader PyCodec_StreamWriter _PyCodec_LookupTextEncoding PyCodec_IgnoreErrors PyCodec_ReplaceErrors PyCodec_XMLCharRefReplaceErrors PyCodec_BackslashReplaceErrors PyCodec_NameReplaceErrors PyErr_GetExcInfo PyErr_SetExcInfo PyErr_FormatV PyErr_SetFromErrnoWithFilenameObjects PyErr_SetFromErrnoWithFilenameObject PyErr_SetImportError PyErr_NewException PyErr_NewExceptionWithDoc PyTraceBack_Print PyErr_ProgramText _Py_fopen _Py_fopen_obj PyErr_SyntaxLocationObject PyErr_SyntaxLocationEx PyErr_SyntaxLocation Py_FrozenMain Py_FrozenFlag Py_IgnoreEnvironmentFlag getenv setlocale setbuf Py_SetProgramName Py_Initialize Py_GetVersion Py_GetCopyright PySys_SetArgv PyImport_ImportFrozenModule PyRun_AnyFileExFlags Py_Finalize PyFuture_FromAST PyArg_VaParse _PyArg_VaParse_SizeT PyArg_VaParseTupleAndKeywords _PyArg_VaParseTupleAndKeywords_SizeT _PyArg_NoPositional Py_GetCompiler Py_GetPlatform _PyParser_Grammar PyImport_FrozenModules PyMarshal_ReadObjectFromString _PyImport_DynLoadFiletab _PyImport_Init _PyImportHooks_Init PySys_SetObject _PyImport_AcquireLock _PyImport_ReleaseLock _PyImport_ReInitLock _PyImport_Fini PyThread_free_lock PyImport_Cleanup _PyState_ClearModules _PyGC_CollectNoFail _PyGC_DumpShutdownStats PyImport_GetMagicNumber PyImport_GetMagicTag _PySys_ImplCacheTag _PyImport_FixupExtensionObject _PyState_AddModule _PyImport_FixupBuiltin PyImport_AddModuleObject _PyImport_FindExtensionObject _PyImport_FindBuiltin _PyImport_LoadDynamicModuleWithSpec PyImport_AddModule PyImport_ExecCodeModuleObject PyImport_ExecCodeModuleWithPathnames PyImport_ExecCodeModule PyImport_ExecCodeModuleEx PyImport_GetImporter PySys_GetObject PyImport_ImportFrozenModuleObject PyImport_ImportModuleLevel _PyImportZip_Init PyImport_ReloadModule PyInit_imp PyImport_ExtendInittab PyImport_AppendInittab _PyImport_Inittab _PyImport_FindSharedFuncptr _Py_hashtable_get_entry _Py_hashtable_set _Py_hashtable_foreach _Py_hashtable_destroy fread PyMarshal_WriteLongToFile PyMarshal_WriteObjectToFile _Py_hashtable_compare_direct _Py_hashtable_hash_ptr _Py_hashtable_new PyMarshal_ReadShortFromFile PyMarshal_ReadLongFromFile PyMarshal_ReadObjectFromFile PyMarshal_ReadLastObjectFromFile _Py_fstat_noraise PyMarshal_WriteObjectToString PyMarshal_Init PyEval_CallFunction PyModule_AddStringConstant PyOS_vsnprintf PyFPE_dummy _Py_HashSecret _PyHash_Fini PyHash_GetFuncDef atoi Py_UnbufferedStdioFlag _PySys_SetObjectId PyModule_GetWarningsModule Py_IsInitialized Py_SetStandardStreamEncoding PyOS_FiniInterrupts PyGC_Collect _PyTraceMalloc_Fini _PyFaulthandler_Fini PyInterpreterState_Clear _PyGC_Fini _PyRandom_Fini _PyGILState_Fini PyInterpreterState_Delete Py_GetProgramName Py_SetPythonHome Py_GetPythonHome PyGILState_GetThisThreadState _Py_DumpTracebackThreads PyErr_Display abort nl_langinfo Py_NewInterpreter PyInterpreterState_New PyThreadState_New PyErr_PrintEx PyThreadState_Clear PyThreadState_Delete Py_GetPath PySys_SetPath Py_NoSiteFlag Py_EndInterpreter _Py_PyAtExit Py_AtExit Py_Exit Py_FdIsInteractive Py_InteractiveFlag PyOS_getsig sigaction PyOS_setsig sigemptyset _Py_InitializeEx_Private Py_DontWriteBytecodeFlag Py_HashRandomizationFlag _PyRandom_Init _PyGILState_Init _PySys_Init _PyTime_Init _PyFaulthandler_Init PyOS_InitInterrupts _PyTraceMalloc_Init PySys_HasWarnOptions Py_InitializeEx _Py_RestoreSignals _PyOS_mystrnicmp_hack Py_IsolatedFlag Py_NoUserSiteDirectory Py_UseClassExceptionsFlag Py_InspectFlag Py_QuietFlag PyOS_mystrnicmp PyThread_get_key_value PyThread_set_key_value _PyThreadState_Init _PyThreadState_Prealloc PyState_FindModule PyState_RemoveModule PyThread_delete_key_value PyThreadState_DeleteCurrent PyThreadState_SetAsyncExc PyInterpreterState_Head PyInterpreterState_Next PyInterpreterState_ThreadHead PyThreadState_Next _PyThread_CurrentFrames PyThread_create_key PyThread_delete_key _PyGILState_Reinit PyGILState_Check PyParser_ASTFromStringObject PyRun_SimpleStringFlags Py_CompileStringExFlags PyCompileString Py_SymtableStringObject Py_SymtableString PyParser_ASTFromString PyParser_ASTFromFileObject PyRun_InteractiveOneObject PyRun_InteractiveLoopFlags PyRun_InteractiveOneFlags PyRun_FileExFlags PyRun_SimpleFileExFlags rewind PyParser_ASTFromFile PyParser_SimpleParseFileFlags PyParser_SimpleParseStringFlags PyParser_SimpleParseStringFlagsFilename PyParser_SimpleParseStringFilename PyParser_ClearError PyParser_SetError PyParser_SimpleParseFile PyParser_SimpleParseString PyRun_AnyFile PyRun_AnyFileEx PyRun_AnyFileFlags PyRun_File PyRun_FileEx PyRun_FileFlags PyRun_SimpleFile PyRun_SimpleFileEx PyRun_String PyRun_SimpleString Py_CompileString Py_CompileStringFlags PyRun_InteractiveOne PyRun_InteractiveLoop ceil _PyLong_AsTime_t _PyLong_FromTime_t _PyTime_ObjectToTime_t _PyTime_ObjectToTimespec _PyTime_ObjectToTimeval _PyTime_FromSeconds _PyTime_FromNanoseconds _PyTime_FromSecondsObject _PyTime_FromMillisecondsObject _PyTime_AsSecondsDouble _PyTime_AsNanosecondsObject _PyTime_AsMilliseconds _PyTime_AsMicroseconds _PyTime_AsTimeval _PyTime_AsTimeval_noraise _PyTime_AsTimevalTime_t _PyTime_AsTimespec _PyTime_GetSystemClock clock_gettime _PyTime_GetSystemClockWithInfo clock_getres _PyTime_GetMonotonicClock _PyTime_GetMonotonicClockWithInfo _PyOS_URandom getentropy PySTEntry_Type PySymtable_Build wcscmp _Py_wreadlink wcschr wcsrchr wcsncpy _Py_wrealpath _PySys_GetSizeOf PySys_ResetWarnOptions PySys_AddWarnOptionUnicode PySys_AddWarnOption PySys_AddXOption PySys_GetXOptions PySys_SetArgvEx PySys_WriteStdout Py_GetProgramFullPath Py_GetPrefix Py_GetExecPrefix _PySys_ImplName PyThread_GetInfo PySys_FormatStdout _Py_write_noraise _PyTraceback_Add _Py_DumpTraceback _PyOS_ResetGetOpt _PyOS_opterr _PyOS_optind _PyOS_optarg _PyOS_GetOpt PyOS_mystricmp localeconv strtod strpbrk _Py_strhex_bytes fcntl ioctl _Py_device_encoding _Py_fstat _Py_stat _Py_get_inheritable _Py_set_inheritable _Py_open _Py_open_cloexec_works _Py_open_noraise _Py_wfopen fopen64 _Py_read _Py_wgetcwd _Py_get_blocking _Py_set_blocking dlopen dlerror dlsym PyThread_init_thread PyThread_start_new_thread pthread_attr_init pthread_attr_setstacksize pthread_attr_destroy pthread_create pthread_detach pthread_self pthread_exit sem_init perror sem_destroy PyThread_acquire_lock_timed sem_timedwait sem_trywait sem_wait sem_post pthread_key_create pthread_key_delete pthread_setspecific pthread_getspecific PyThread_ReInitTLS PyThread_get_stacksize PyThread_set_stacksize confstr PyInit__thread PyInit__signal PyInit_posix PyInit_errno PyInit_pwd PyInit__sre PyInit__codecs PyInit__weakref PyInit__functools PyInit__operator PyInit__collections PyInit_itertools PyInit_atexit PyInit__stat PyInit_time PyInit__locale PyInit__io PyInit_zipimport PyInit_faulthandler PyInit__tracemalloc PyInit__symtable PyInit_xxsubtype PyInit_gc wcscpy wcscat wcsncat fseek wcstok Py_SetPath Py_Main strtok setvbuf Py_GetArgcArgv _PyGC_Dump _PyObject_GC_Calloc PyErr_SetInterrupt sigaddset _PyLong_FromUid sigwait sigismember alarm getpid sigpending siginterrupt getitimer setitimer PySignal_SetWakeupFd __libc_current_sigrtmin __libc_current_sigrtmax sigtimedwait sigwaitinfo pthread_sigmask pthread_kill pause PyOS_AfterFork _PyOS_IsMainThread _Py_Uid_Converter _Py_Gid_Converter gnu_dev_makedev gnu_dev_minor gnu_dev_major sendfile64 setgroups qsort sysconf readlinkat flistxattr llistxattr fremovexattr lremovexattr fsetxattr lsetxattr fgetxattr lgetxattr setresgid setresuid getloadavg fpathconf fstatvfs64 fdatasync fsync fchdir unsetenv putenv posix_fadvise64 posix_fallocate64 mkfifoat mkfifo pipe2 pipe pwrite64 pread64 readv lockf64 dup3 dup2 openat64 tcsetpgrp tcgetpgrp setpgid setsid getsid waitpid wait4 wait3 getpgid initgroups setregid setegid setgid setreuid seteuid setuid killpg getlogin getppid forkpty openpty __sched_cpualloc sched_getaffinity __sched_cpufree __sched_cpucount sched_setaffinity sched_yield sched_setscheduler sched_setparam sched_rr_get_interval sched_getscheduler sched_getparam sched_get_priority_min sched_get_priority_max fork fexecve execv times unlinkat unlink uname umask system rmdir setpriority getpriority nice mkdirat mkdir fdopendir readdir64 rewinddir closedir ctermid chroot lchown fchown fchmod ttyname access faccessat ftruncate64 fchmodat fchownat writev symlinkat symlink renameat rename utimensat futimens getresuid waitid getuid geteuid _PyLong_FromGid getresgid getgroups getgrouplist getgid getegid getpwuid setpwent getpwent endpwent getpwnam localtime tzset clock getrusage wcsftime mktime gmtime select clock_settime bindtextdomain dcgettext wcsxfrm wcscoll bind_textdomain_codeset PyFileIO_Type PyBufferedReader_Type PyBufferedRandom_Type PyBufferedWriter_Type PyTextIOWrapper_Type PyNumber_AsOff_t _PyIO_ConvertSsize_t _PyIO_get_module_state _PyIO_Module _PyIO_get_locale_module PyIOBase_Type PyRawIOBase_Type PyBufferedIOBase_Type PyTextIOBase_Type PyBytesIO_Type _PyBytesIOBuffer_Type PyStringIO_Type PyBufferedRWPair_Type PyIncrementalNewlineDecoder_Type _PyIO_str_close _PyIO_str_closed _PyIO_str_decode _PyIO_str_encode _PyIO_str_fileno _PyIO_str_flush _PyIO_str_getstate _PyIO_str_isatty _PyIO_str_newlines _PyIO_str_read _PyIO_str_read1 _PyIO_str_readable _PyIO_str_readall _PyIO_str_readinto _PyIO_str_readline _PyIO_str_reset _PyIO_str_seek _PyIO_str_seekable _PyIO_str_setstate _PyIO_str_tell _PyIO_str_truncate _PyIO_str_write _PyIO_str_writable _PyIO_str_nl _PyIO_empty_str _PyIO_empty_bytes _PyIO_zero _PyIO_trap_eintr _PyIOBase_check_closed _PyIOBase_check_seekable _PyIOBase_check_readable _PyIOBase_check_writable _PyIOBase_finalize _PyFileIO_closed _PyIncrementalNewlineDecoder_decode _PyIO_find_line_ending getrlimit64 setrlimit64 sigfillset sigaltstack _Py_hashtable_size _Py_hashtable_clear _Py_hashtable_pop _Py_hashtable_get _Py_hashtable_new_full _Py_hashtable_copy _Py_hashtable_hash_int _Py_hashtable_delete _Py_M__importlib_external _Py_M__importlib libpthread.so.0 libdl.so.2 libutil.so.1 libm.so.6 libc.so.6 __environ __xstat64 __fxstat64 __lxstat64 __fxstatat64 __xmknod __xmknodat _edata __bss_start _end libpython3.5m.so.1.0 GLIBC_2.27                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         -                                        7                              4                                                                                      h                                                                                                        H
                       (                 0            X     8            P
     @            X
     H            h
     P            8     `            H     p            X                 h                 x                                                                                     h                 p                  x                                        0                 @                 P                 `                 p                                                                                                                                                                                                               0                 @                 P                  `            (     p            0                 8                 @                 H                 P                 X                 `                 h                 p                  